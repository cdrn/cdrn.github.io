<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Eth contract data pt 2. Storage tree, cast and RPC</title>
        <meta
        name="description" content="Let&#39;s investigate a command line tool to help us understand the storage tree">
        <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Chris&#39; blog">
        <link rel="alternate" href="/feed/feed.json" type="application/json" title="Chris&#39; blog">
        
        <style>
    /**
 * okaidia theme for JavaScript, CSS and HTML
 * Loosely based on Monokai textmate theme by http://www.monokai.nl/
 * @author ocodia
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #f8f8f2;
	background: none;
	text-shadow: 0 1px rgba(0, 0, 0, 0.3);
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #8292a2;
}

.token.punctuation {
	color: #f8f8f2;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
	color: #f92672;
}

.token.boolean,
.token.number {
	color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function,
.token.class-name {
	color: #e6db74;
}

.token.keyword {
	color: #66d9ef;
}

.token.regex,
.token.important {
	color: #fd971f;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
/*
 * New diff- syntax
 */

pre[class*="language-diff-"] {
	--eleventy-code-padding: 1.25em;
	padding-left: var(--eleventy-code-padding);
	padding-right: var(--eleventy-code-padding);
}
.token.deleted {
	background-color: hsl(0, 51%, 37%);
	color: inherit;
}
.token.inserted {
	background-color: hsl(126, 31%, 39%);
	color: inherit;
}

/* Make the + and - characters unselectable for copy/paste */
.token.prefix.unchanged,
.token.prefix.inserted,
.token.prefix.deleted {
	-webkit-user-select: none;
	user-select: none;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	padding-top: 2px;
	padding-bottom: 2px;
}
.token.prefix.inserted,
.token.prefix.deleted {
	width: var(--eleventy-code-padding);
	background-color: rgba(0,0,0,.2);
}

/* Optional: full-width background color */
.token.inserted:not(.prefix),
.token.deleted:not(.prefix) {
	display: block;
	margin-left: calc(-1 * var(--eleventy-code-padding));
	margin-right: calc(-1 * var(--eleventy-code-padding));
	text-decoration: none; /* override del, ins, mark defaults */
	color: inherit; /* override del, ins, mark defaults */
}
* { box-sizing: border-box; }
/* Defaults */
:root {
	--font-family: -apple-system, system-ui, sans-serif;
	--font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono, Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono, Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New, Courier, monospace;
}

/* Theme colors */
:root {
	--color-gray-20: #e0e0e0;
	--color-gray-50: #C0C0C0;
	--color-gray-90: #333;

	--background-color: #fff;

	--text-color: var(--color-gray-90);
	--text-color-link: #082840;
	--text-color-link-active: #5f2b48;
	--text-color-link-visited: #17050F;

	--syntax-tab-size: 2;
}

@media (prefers-color-scheme: dark) {
	:root {
		--color-gray-20: #e0e0e0;
		--color-gray-50: #C0C0C0;
		--color-gray-90: #dad8d8;

		/* --text-color is assigned to --color-gray-_ above */
		--text-color-link: #1493fb;
		--text-color-link-active: #6969f7;
		--text-color-link-visited: #a6a6f8;

		--background-color: #15202b;
	}
}


/* Global stylesheet */
* {
	box-sizing: border-box;
}

html,
body {
	padding: 0;
	margin: 0 auto;
	font-family: var(--font-family);
	color: var(--text-color);
	background-color: var(--background-color);
}
html {
	overflow-y: scroll;
}
body {
	max-width: 40em;
}

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

p:last-child {
	margin-bottom: 0;
}
p {
	line-height: 1.6em;
}

li {
	line-height: 1.6em;
}

a[href] {
	color: var(--text-color-link);
}
a[href]:visited {
	color: var(--text-color-link-visited);
}
a[href]:hover,
a[href]:active {
	color: var(--text-color-link-active);
}

main {
	padding: 1rem;
}
main :first-child {
	margin-top: 0;
}

header {
	border-bottom: 1px dashed var(--color-gray-20);
}
header:after {
	content: "";
	display: table;
	clear: both;
}

.links-nextprev {
	list-style: none;
	border-top: 1px dashed var(--color-gray-20);
	padding: 1em 0;
}

table {
	margin: 1em 0;
}
table td,
table th {
	padding-right: 1em;
}

pre,
code {
	font-family: var(--font-family-monospace);
}
pre:not([class*="language-"]) {
	margin: .5em 0;
	line-height: 1.375; /* 22px /16 */
	-moz-tab-size: var(--syntax-tab-size);
	-o-tab-size: var(--syntax-tab-size);
	tab-size: var(--syntax-tab-size);
	-webkit-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
}
code {
	word-break: break-all;
}

/* Header */
header {
	display: flex;
	gap: 1em .5em;
	flex-wrap: wrap;
	align-items: center;
	padding: 1em;
}
.home-link {
	font-size: 1em; /* 16px /16 */
	font-weight: 700;
	margin-right: 2em;
}
.home-link:link:not(:hover) {
	text-decoration: none;
}

/* Nav */
.nav {
	display: flex;
	padding: 0;
	margin: 0;
	list-style: none;
}
.nav-item {
	display: inline-block;
	margin-right: 1em;
}
.nav-item a[href]:not(:hover) {
	text-decoration: none;
}
.nav a[href][aria-current="page"] {
	text-decoration: underline;
}

/* Posts list */
.postlist {
	list-style: none;
	padding: 0;
	padding-left: 1.5rem;
}
.postlist-item {
	display: flex;
	flex-wrap: wrap;
	align-items: baseline;
	counter-increment: start-from -1;
	margin-bottom: 1em;
}
.postlist-item:before {
	display: inline-block;
	pointer-events: none;
	content: "" counter(start-from, decimal-leading-zero) ". ";
	line-height: 100%;
	text-align: right;
	margin-left: -1.5rem;
}
.postlist-date,
.postlist-item:before {
	font-size: 0.8125em; /* 13px /16 */
	color: var(--color-gray-90);
}
.postlist-date {
	word-spacing: -0.5px;
}
.postlist-link {
	font-size: 1.1875em; /* 19px /16 */
	font-weight: 700;
	flex-basis: calc(100% - 1.5rem);
	padding-left: .25em;
	padding-right: .5em;
	text-underline-position: from-font;
	text-underline-offset: 0;
	text-decoration-thickness: 1px;
}
.postlist-item-active .postlist-link {
	font-weight: bold;
}

/* Tags */
.post-tag {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	text-transform: capitalize;
	font-style: italic;
}
.postlist-item > .post-tag {
	align-self: center;
}

/* Tags list */
.post-metadata {
	display: inline-flex;
	flex-wrap: wrap;
	gap: .5em;
	list-style: none;
	padding: 0;
	margin: 0;
}
.post-metadata time {
	margin-right: 1em;
}

/* Direct Links / Markdown Headers */
.header-anchor {
	text-decoration: none;
	font-style: normal;
	font-size: 1em;
	margin-left: .1em;
}
a[href].header-anchor,
a[href].header-anchor:visited {
	color: transparent;
}
a[href].header-anchor:focus,
a[href].header-anchor:hover {
	text-decoration: underline;
}
a[href].header-anchor:focus,
:hover > a[href].header-anchor {
	color: #aaa;
}

h2 + .header-anchor {
	font-size: 1.5em;
}</style>
    </head>
    <body>
        <a href="#skip" class="visually-hidden">Skip to main content</a>
        <header>
            <a href="/" class="home-link">Chris&#39; blog</a>
            <nav>
                <h2 class="visually-hidden">Top level navigation menu</h2>
                <ul class="nav">
                        <li class="nav-item">
                            <a href="/" >Home</a>
                        </li>
                        <li class="nav-item">
                            <a href="/blog/" >Archive</a>
                        </li>
                        <li class="nav-item">
                            <a href="/about/" >About Me</a>
                        </li>
                </ul>
            </nav>
        </header>
        <main id="skip">
            
<h1>Eth contract data pt 2. Storage tree, cast and RPC</h1>

<ul class="post-metadata">
	<li><time datetime="2023-08-28">28 August 2023</time></li>
	<li><a href="/tags/ethereum-thegraph-forge-contract-data-mempool-storage/" class="post-tag">ethereum, thegraph, forge, contract data, mempool, storage</a></li>
</ul>

<p>I recently gave a talk at <a href="https://ethmelbourne.co/">eth melbourne</a> in which i gave some tips and tricks for indexing eth contract data, as well as a brief overview of exactly <em>what</em> contract data is on ethereum and a quick dive into the EVM. This is part two of a two part blog post - you can find the first part <a href="https://cdrn.github.io/blog/slurpingcontractdatapt1/">here</a>. In this part, I want to cover some of your best options for getting into the yummy stuff (contract data) in both scalable and unscalable ways.</p>
<h2 id="what-is-the-storage-tree" tabindex="-1">What is the storage tree <a class="header-anchor" href="#what-is-the-storage-tree">#</a></h2>
<p>In our last post, we talked a little bit about how contract data is stored in a &quot;patricia merkle&quot; tree called the ethereum storage tree. In order to demystify this a little, I want to get into the nitty gritty of manually grabbing items off of this trie so you can see how both accessible it is and how we can build up our own state database over time</p>
<p><picture><source type="image/avif" srcset="/img/WdB1jpd5US-300.avif 300w, /img/WdB1jpd5US-600.avif 600w" sizes="(max-width: 991px) 193px, 278px"><source type="image/webp" srcset="/img/WdB1jpd5US-300.webp 300w, /img/WdB1jpd5US-600.webp 600w" sizes="(max-width: 991px) 193px, 278px"><source type="image/png" srcset="/img/WdB1jpd5US-300.png 300w, /img/WdB1jpd5US-600.png 600w" sizes="(max-width: 991px) 193px, 278px"><img alt="A great explanation of how the ethereum state tree works [credit here](https://ethereum.stackexchange.com/questions/6415/eli5-how-does-a-merkle-patricia-trie-tree-work)" loading="lazy" decoding="async" src="/img/WdB1jpd5US-300.png" width="600" height="423"></picture></p>
<p>Ethereum in it's current implementation (as of 2023) actually utilises <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#tries-in-ethereum">3 patricia merkle trees</a> which have the following useful properties:</p>
<ol>
<li>Their lookup and retrieval time is O(k) where k is key length -- in Ethereum always 20 bytes.</li>
<li>Leaf nodes are cryptographically verifiable by only needing to store the state of the path to the root node (the state root) - this means clients do not need the entire state of the tree to verify whether a piece of data is legitimate or not.
For this reason, storage in eth is more or less treated as a hashmap which is especially good news for us if we are interested in mass retrieval - we can be sure it will be relatively fast and we will will also be able to parallelize it (should we so choose)</li>
</ol>
<p>The storage tree is just the Patricia Merkle Tree that stores all of the &quot;storage&quot; data from the execution of Eth smart contracts. If a contract requires between block, between call memory storage, this is the data structure it lives in</p>
<h2 id="interrogating-the-storage-state-tree" tabindex="-1">Interrogating the storage/state tree <a class="header-anchor" href="#interrogating-the-storage-state-tree">#</a></h2>
<p>For first time ethereum users, the best way to get a handle on the structure and operation of contract data on the chain is using foundry's <a href="https://github.com/foundry-rs/foundry/tree/master/crates/cast"><code>cast</code> tool</a>. Cast provides a lot of convenience and hides some of the ugliest parts of interacting with ethereum's <a href="https://ethereum.org/en/developers/docs/apis/json-rpc/">underlying RPC methods</a> which will become obvious later in this post.</p>
<p>Foundry is easy to install by <a href="https://book.getfoundry.sh/getting-started/installation">following these docs</a> which I've paraphrased below for convenience. In your terminal, run:</p>
<pre class="language-bash" tabindex="0"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> https://foundry.paradigm.xyz <span class="token operator">|</span> <span class="token function">bash</span></code></pre>
<p>Once foundry is installed simply run</p>
<pre class="language-bash" tabindex="0"><code class="language-bash">foundryup</code></pre>
<p>and you should have access to the <code>cast</code> command in your command line. You can type in <code>cast</code> to see the subcommands available to you. This also comes with <code>forge</code>, <code>anvil</code>, and <code>chisel</code>.</p>
<p>You're going to need an ethereum node to talk to. Either you can set up and run your own locally, or more conveniently <a href="https://app.infura.io/dashboard">grab a free infura API key</a>. Once you've got an API URL, set the env var in your console like so</p>
<pre class="language-bash" tabindex="0"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ETH_RPC_URL</span><span class="token operator">=</span><span class="token operator">&lt;</span>YOUR_INFURA_URL<span class="token operator">></span></code></pre>
<p>For now, let's try inspecting the state of a live smart contract to hopefully demystify the inner workings of the eth chain. The contract for the uniswap governance token lives <a href="https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984">here</a>. Let's grab it and see what it looks like. We can introspect the storage attached to the contract super easily with the following cast command:</p>
<pre class="language-bash" tabindex="0"><code class="language-bash">cast storage 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984</code></pre>
<p>Your output should look something like the following:</p>
<pre><code>| Name                | Type                                                         | Slot | Offset | Bytes | Value                                            | Contract             |
|---------------------|--------------------------------------------------------------|------|--------|-------|--------------------------------------------------|----------------------|
| totalSupply         | uint256                                                      | 0    | 0      | 32    | 1000000000000000000000000000                     | Uni/Contract.sol:Uni |
| minter              | address                                                      | 1    | 0      | 20    | 151923958270022490478906441731290990705404425660 | Uni/Contract.sol:Uni |
| mintingAllowedAfter | uint256                                                      | 2    | 0      | 32    | 1704067200                                       | Uni/Contract.sol:Uni |
| allowances          | mapping(address =&gt; mapping(address =&gt; uint96))               | 3    | 0      | 32    | 0                                                | Uni/Contract.sol:Uni |
| balances            | mapping(address =&gt; uint96)                                   | 4    | 0      | 32    | 0                                                | Uni/Contract.sol:Uni |
| delegates           | mapping(address =&gt; address)                                  | 5    | 0      | 32    | 0                                                | Uni/Contract.sol:Uni |
| checkpoints         | mapping(address =&gt; mapping(uint32 =&gt; struct Uni.Checkpoint)) | 6    | 0      | 32    | 0                                                | Uni/Contract.sol:Uni |
| numCheckpoints      | mapping(address =&gt; uint32)                                   | 7    | 0      | 32    | 0                                                | Uni/Contract.sol:Uni |
| nonces              | mapping(address =&gt; uint256)                                  | 8    | 0      | 32    | 0                                                | Uni/Contract.sol:Uni |
</code></pre>
<p>This is showing us the values stored at a given storage address in the ethereum storage tree. Neat! We can even see the values in decimal here - although keep in mind for things like <code>totalSupply</code> this is in base units - to get the whole unit value you have to divide by <code>10^18</code>. Cast is, however, doing a lot behind the scenes to get us here. Cast first does the following:</p>
<ol>
<li>Goes to etherscan to retrieve the ABIs or Application Binary Interfaces required to interpret the deployed contracts. Without the ABIs, it's impossible to interpret the data correctly. Etherscan, Blockscout and other block explorers allow contract writers to upload <a href="https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code">verified versions of contracts</a></li>
<li>Makes the required RPC calls which take and receive arguments in hex</li>
<li>Translates the received RPC responses from hex to decimal (You can also use cast's build in <code>hex-to-dec</code>)</li>
</ol>
<p>These are a few extra steps, but hypothetically anyone could go directly to the requisite ethereum RPCs and grab the data!</p>
<h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps">#</a></h2>
<p>Woof, that was a lot! In the next post i'll quickly go over your best and quickest ways to index ethereum contract data at scale. I'll also upload the slide deck from the talk.</p>

<ul class="links-nextprev"><li>Previous: <a href="/blog/slurpingcontractdatapt1/">Eth contract data pt 1.</a></li>
</ul>

        </main>
        <footer></footer>
        <!-- Current page: /blog/slurpingcontractdatapt2/ -->
    </body>
</html>