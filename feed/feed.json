{
	"version": "https://jsonfeed.org/version/1.1",
	"title": "Chris Doran",
	"language": "en",
	"home_page_url": "https://cdrn.github.io/",
	"feed_url": "https://cdrn.github.io/feed/feed.json",
	"description": "blög",
	"author": {
		"name": "Chris",
		"url": "https://cdrn.github.io/about-me/"
	},
	"items": [
		{
			"id": "https://cdrn.github.io/blog/speed-of-law-vs-blocks/",
			"url": "https://cdrn.github.io/blog/speed-of-law-vs-blocks/",
			"title": "On the speed of law versus the speed of blocks",
			"content_html": "<h2 id=\"1-a-short-history-of-blacklist\" tabindex=\"-1\">1. A short history of blacklist() <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>Since the beginning, stablecoins have shipped with <a href=\"https://etherscan.io/address/0x43506849d7c04f9138d1a2050bbf3a0c054402dd#code#F15#L71\">freeze</a>, <a href=\"https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L269\">blacklist</a> functions. And it makes sense - centralised stablecoin issuers, exposed to US treasuries and ostensibly operating a privately issued US dollar need to have some compliance story - and the blacklist gets used. <a href=\"https://crypto.news/tether-freezes-30x-more-value-than-circle-as-stablecoin-blacklists-surge/\">Tether has frozen $3.3B</a> since 2023, working with 275 law enforcement agencies across 59 jurisdictions. Circle has been surprisingly more conservative - $109M, court orders only. There is a real capability that exists today.</p>\n<p>The GENIUS act <a href=\"https://www.banking.senate.gov/newsroom/majority/myth-vs-fact-the-genius-act\">codifies</a> this: issuers must have &quot;technological capability to comply with any lawful order to freeze funds&quot;. What was a nod is now a mandate, but mandating a capability doesn't necessarily make it fast.</p>\n<h2 id=\"2-the-race-to-broadcast\" tabindex=\"-1\">2. The race to broadcast <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>A swap on Thorchain settles in under a minute. Uniswap is one block, which is 12 seconds on Ethereum mainnet and soon to be 6. The attacker's workflow is: receive funds, approve, swap, done. The future blacklistee is  holding native BTC or ETH which no blacklist function in the world can touch (That's the point!). Hackers and bad actors are constrained only by how quickly they can dump funds into liquid pools, and whether there are sufficient willing, able or ignorant marketmakers to replenish them. For small denominations, this is almost meaningless and there is sufficient liquidity in pools to cover substantial amounts of the hacked funds in the next block.</p>\n<p>The issuer side is a different story. Tether runs a multisig. This means the issuer is forced to play an awkward co-ordination game for every action. One needs multiple signers to coordinate, sign, broadcast for every blacklist action. Amlbot <a href=\"https://blog.amlbot.com/tether-freeze-gap-becomes-laundering-loophole-for-criminals-an-analytical-report/\">clocked their average observed latency</a> at 44 minutes from freeze decision to on-chain enforcement. During that window, $78mm walked out of addresses that had been publicly flagged. The blacklist transaction was still pending. One can imagine this arms race escalating with faster signing (threshold signatures), improved governance procedures, a contract that makes blacklisting simpler and requires fewer quorum. However, one can also imagine Lazarus bribing a block builder for top of block to get their transfers in before blacklist function calls. Are issuers now required to have sophisticated MEV capabilities? We can move the problem around the plate, but it appears, not solve it.</p>\n<p>The law imagines freeze like a bank: point at account, flip a bit, funds stop, but a bank ledger is a single database with atomic writes. on-chain you're broadcasting a tx that has to confirm, and the attacker is broadcasting theirs at the same time. It's a race. and 12 seconds vs 44 minutes isn't a race.</p>\n<h2 id=\"3-the-scoreboard-today\" tabindex=\"-1\">3. The scoreboard today <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>Here's the standing tally</p>\n<p>Bybit, February 2025: <a href=\"https://www.bleepingcomputer.com/news/security/fbi-confirms-lazarus-hackers-were-behind-15b-bybit-crypto-heist/\">Lazarus Group takes $1.5B</a> in ETH and staking derivatives. They don't touch USDC. Within 48 hours, $160M has been converted to native BTC via THORChain. Within 10 days, the entire haul - all $1.4B - has been <a href=\"https://beincrypto.com/lazarus-laundered-bybit-hack-funds-via-thorchain/\">swapped and distributed</a> across 6,954 wallets. THORChain processes $5.5B in volume during the laundering window. Chainflip handles some of the flow too. A THORChain core developer <a href=\"https://cointelegraph.com/news/timeline-bybit-lost-ethereum-north-korea-money-launder\">resigns in protest</a>. Validators attempt to block the transactions and get overruled by the protocol's governance.</p>\n<p>Tether <a href=\"https://www.ccn.com/education/crypto/ben-zhou-bybit-1-5-billion-hack-explained/\">freezes $181k</a>. That's 0.012% of the stolen funds.</p>\n<p>The attackers understood the asset model. They never held freezable assets for longer than it took to swap out of them. The blacklist function was irrelevant - not because it didn't work, but because they routed around it entirely.</p>\n<p>Multichain, July 2023: An attacker, possibly an insider, <a href=\"https://www.chainalysis.com/blog/multichain-exploit-july-2023/\">drains $126M</a> from the bridge protocol. Around $65M is USDC and USDT. And then... nothing. No swaps. No bridges. The funds sit in the exploit addresses. Within 24 hours, Circle and Tether freeze $67.5M - over half the total haul. That money is still frozen. A New York bankruptcy court <a href=\"https://www.theblock.co/post/377094/multichain-extends-freeze-stolen-usdc\">extended the freeze order</a> in October 2025.</p>\n<p>Same capability. Wildly different outcomes. The difference isn't the freeze function. It's attacker competence.</p>\n<p>Bybit was a state-sponsored operation that understood exactly how to exit freezable rails. Multichain was either an insider who thought they could negotiate, or someone who didn't understand what they were holding. The blacklist caught the second one. It didn't touch the first.</p>\n<p>So what is this for? $3.3B frozen sounds impressive until you realise it's mostly people who didn't know they were holding a traceable asset. The Lazarus playbook isn't secret anymore either, it's on-chain for anyone to read. More than that, it has entered the canon in a somewhat mythical status. The next attacker is very unlikely to be unaware, and so unlikely to sit still.</p>\n<h2 id=\"4-the-building-with-no-walls\" tabindex=\"-1\">4. The building with no walls <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p><code>blacklist()</code> regulates stablecoins. Stablecoins exist in an ecosystem of permissionless swaps, bridges, and liquidity pools. You can lock a door, but it's useless if the building has no walls.</p>\n<p>Most credibly decentralised protocols (THORChain) don't have a blacklist function by design - and frankly, definition. It, and other related protocols are decentralised clearinghouses for swapping on chain assets. The protocol doesn't custody funds, doesn't have an issuer, doesn't have a compliance team. It just matches swaps. Chainflip is the same architecture. Garden, similar again (if we take liberties with the underlying settlement mechanism). The fundamental conceit of any non-custodial decentralised exchange is that it exists somewhere closer to &quot;permissionless&quot; than &quot;permissioned&quot; on the gradient, either in actuality, or as regulatory arbitrage, otherwise, why not just be a centralised exchange?</p>\n<p>This is very obviously the point of DeFi. Permissionless means permissionless. If it doesn't, then this sets an awkward legal precedent. Lazarus' pragmatic use of existing cross chain rails was not a loophole, but infrastructure operating as it was intended.</p>\n<p>The uncomfortable question for anyone building this infrastructure: what happens when regulators figure out that the game isn't asset control, but flow control?</p>\n<h2 id=\"5-the-impossible-position\" tabindex=\"-1\">5. The impossible position <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>THORChain validators found out in real time. During the Bybit laundering, three validators voted to halt transactions linked to Lazarus addresses. They were overruled within minutes - the protocol's governance didn't support intervention. A core developer quit publicly. The community split between &quot;we have to do something&quot; and &quot;if we can do something, we're not decentralised.&quot; This is the core issue. If your protocol can block transactions on demand, you're a permissioned system with extra steps and you've just volunteered for the same compliance obligations as Coinbase. If you can't, you're the exit route for state-sponsored money laundering, and eventually someone in Washington notices.</p>\n<p>The precedent set by Tornado Cash tips the scales toward direct action. OFAC sanctioned the smart contracts directly in 2022. Not an issuer or company, but the code itself. A developer went to prison. The legal theory was novel and contested, but the effect was immediate: touch this infrastructure and you're exposed. It's hard to understate the ripples this sent through the developer community. For years, privacy was solely the domain of the cracked, crazy or both.</p>\n<p>It seems very obvious that once the freeze-at-issuer theatre becomes too inconvenient to ignore, attention shifts to the permissionless rails that facilitate the movement. Any cross chain venue with liquidity and no KYC becomes an obvious place to stop the bleeding. Resultantly, anyone building in this space has to pick a position - either permissionless enough to be useful to Lazarus, or permissioned enough to be compliant.</p>\n<h2 id=\"6-where-this-goes\" tabindex=\"-1\">6. Where this goes <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>So is the GENIUS Act freeze mandate useless? Not entirely. It catches static funds, dumb attackers, people who don't understand the asset they're holding. $3.3B frozen is a substantial amount of money, even if it's mostly the bottom of the competence distribution. But as a regime for stopping sophisticated actors - state-sponsored or otherwise - it's mostly theatre. The law mandates a capability that structurally cannot do what is asked of it.</p>\n<p>From here the enforcement surface will likely shift. Validator and node operator sanctions, frontend takedowns, pressure on wallets to drop integration with non-compliant venues. The &quot;travel rule for DeFi&quot; discourse is already warming up in FATF working groups. The first attempts are likely to be clumsy (much like the GENIUS act) but substantive. Eventually, they will improve.</p>\n<p>Beyond this, &quot;compliant cross-chain&quot; might not be coherent under AMM architecture. The pool doesn't know who's swapping. There's no hook to reject a specific taker. You could bake a blacklist into the contract, but now you've added a centralised dependency, an attack surface, and latency to every swap. It's possible. It's also ugly, and it defeats much of the point.</p>\n<p>Intent based systems have the capability to be different. The maker sees the counterparty before filling. They can screen, price the risk, or walk away. The protocol stays neutral. The compliance decision moves to the entity with something to lose and the risk gets priced into the spread rather than blocked at the gate. In this way it might be possible to have both. An explosion of issuer-specific stablecoins is coming. For payments to work, they need to interoperate. The first group to do this correctly (on neutral ground) stands to take the whole pie, but the devil is in the details. The immutable parts must be immutable, and the makers responsible for their own fills. I will expand on this in a later post. For now: freeze catches what sits still. It's a dragnet for the left end of the bell curve. Everything else is in motion.</p>\n",
			"date_published": "2025-12-27T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/whatsgoingonstables/",
			"url": "https://cdrn.github.io/blog/whatsgoingonstables/",
			"title": "Stablecoins: What happens when the risk free rate is money",
			"content_html": "<h2 id=\"what-the-hell-is-going-on-with-stables\" tabindex=\"-1\">What the hell is going on with stables? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>A spectre is haunting DEFI -- the spectre of treasury bills.</p>\n<p>Stablecoins are the talk of the town currently. Financial institutions are scrambling over each other to compete for their favourite thing: using other people's money to pocket <em>the risk free rate</em>. Or, in other words - using other people's money to buy US treasuries. Not a bad business model! But they're a decade late.</p>\n<p>For those who don't know, Stablecoins like USDT and USDC (known as <em>&quot;Dollar backed&quot; stablecoins</em>) are dollar pegged tokens for deployment on a blockchain. For every dollar, an institution will normally buy a corresponding share of a US treasury bill which pays 2-7 percent anually - known as the <em><a href=\"https://en.wikipedia.org/wiki/Risk-free_rate#:~:text=The%20risk%2Dfree%20rate%20of,to%20meet%20all%20payment%20obligations.\">risk free rate</a></em>.  In this way, these issuers have become massively profitable enterprises - <a href=\"https://www.reuters.com/business/finance/fidelity-investments-tests-dollar-pegged-stablecoin-2025-03-26/\">and tradfin is noticing</a>.</p>\n<p>These enterprises have struck a simple bargain with crypto users and institutions for the past decade now: They will continue to redeem their tokens for US dollars indefinitely, virtually guaranteeing its peg. In exchange, they will pocket the sum total of the risk free rate. This business has been held up by 1. The highly profitable nature of cryptocurrency over the past decade - where users have previously had more and better opportunities for yield and 2. The absolute utility of a no questions asked, 0 KYC on chain USD alternative usable for whatever you see fit - a not inconsiderable risk for the issuer. Massive amounts of competition are about to enter the space - and here's what I think they haven't priced in:</p>\n<h2 id=\"1-yield-passed-directly-to-the-user\" tabindex=\"-1\">1. Yield passed directly to the user <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>USDC and USDT have been tolerated for so long due to their position as <em>regulatory arbitrageurs</em>. On chain users were willing to delegate their yield to these issuers in exchange for them taking the regulatory risk around a new and previously unknown technology. This isn't the case anymore.</p>\n<p>If the utility of these issuers legal war chest is no longer in play, issuers will have to compete in the way that other financial instruments do: on yield. Some savvy issuers are already <a href=\"https://www.ledgerinsights.com/figure-launches-sec-regulated-yield-bearing-stablecoin/\">frontrunning this</a>, although are backing their tokens with less conventional asset classes. Nonetheless, i expect there will be a race to the bottom in terms of &quot;who can offer stablecoin holders closer to the risk free rate&quot;. Issuers, having no real platform on which users can buy and sell goods and services on, rely on their circulating supply being propped up by other vendor's acceptance of their coins. With institutional players stepping in, I expect this to change quickly. They will need to sweeten the deal. I predict there will be a race toward the risk free rate, with different vendors occupying different slots on the risk &lt;&gt; yield curve.</p>\n<p>I don't know what the implications are for this on federal monetary policy - but i imagine they're not good. After all, when everyone gets yield, no-one gets yield, and so <em>the risk free rate becomes zero</em>, or more accurately, the spread between money and t-bills trends toward zero. High interest rate environments will make this GLARING. The difference between your lossy dollars and your yield bearing stablecoins (at 5.5%!) will be substantial. A new liquid asset class that directly disintermediates federal monetary policy? Satoshi blushes.</p>\n<h2 id=\"2-tradfi-competes-at-the-speed-of-wire-defi-simply-vampires\" tabindex=\"-1\">2. Tradfi competes at the speed of wire - DEFI simply vampires <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>The race to give token holders the best yield could be vicious. Tradfin is accustomed to competing within walled gardens, but crypto is both open and even with tokenised RWAs, somewhat <em>permissionless</em>. This creates some wrinkles for issuers.</p>\n<p>Say, hypothetically, i am an aggressive new stablecoin issuer. I create an aggressive yield low risk stablecoin with good distribution. Maybe i even have a network of users and use cases already - great! But circle has 50 billion tokens floating around. And what's worse, my users own a lot of them!</p>\n<p>So, what if, as an issuer - i <em>accept other stablecoins</em>. I route them to arbitrageurs who burn them through their individual contracts with issuers. I use the new US dollar liquidity (at a small 15 bip impact to me!) to mint more of my own stablecoin, which i put back into circulation through pools, user withdrawals, or other methods. I'm directly draining the liquidity from their stablecoin and turning it into my own, thus pocketing any associated yield and better yet, diminishing their position. If they cease redeeming to the arbitrageurs, their coin will lose it's peg, or worse, they will breach contract. If they keep redeeming, they may have to keep selling bonds until there are none left, and are no longer profitable. This is one way to unwind an issuer.</p>\n<p>Issuers can fight this in a few ways: by offering different backing assets (although, this is limited by regulation), risk profiles and yield amounts. I expect however, they will fight this with contracts - mint/burn agreements with enterprises and arbitrageurs that strictly limit the total possible outflows. This still doesn't solve the problem - but may stem the bleeding.</p>\n<h2 id=\"3-order-flow-is-king\" tabindex=\"-1\">3. Order flow is king <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>One key learning from DEFI in the 2023-2024 era is that value accrues to order flow. Order flow to ethereum and solana block builders means more MEV. Bananagun, pump.fun, Jito, all make substantial profits from order flow. Ultimately, platforms come and go, but value accrues to orderflow.</p>\n<p>In this new stablecoin regime, issuers with organic orderflow have an opportunity to take advantage. In a world of hyper capital efficient stablecoin flows and vampire attacks, the game becomes: <em>who can keep their coins circulating the longest</em>. The most obvious way to do this: have a reason to use them. PYUSD - though not yet &quot;crossed the chasm&quot; at the time of writing, is a great example of this. <a href=\"https://www.moomoo.com/community/feed/solana-and-visa-bridging-the-gap-between-crypto-and-payments-112091813511174#:~:text=The%20partnership%20between%20Solana%20and,transactions%20on%20a%20global%20scale.\">Visa is also getting their foot in the door </a>here. Stablecoins that have a reason to be, will be. Those that don't, may not survive.</p>\n<h2 id=\"so-what\" tabindex=\"-1\">So, what? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>In a world where money itself yields 5%+, the stablecoin game becomes one of distribution, risk management, and network effects. Survival means offering actual utility beyond mere existence. The winners will be those who build moats through real transaction volume rather than regulatory arbitrage or trying to nickel and dime yield from users. The cost will be 5%, but the prize could be the world's transaction volume.</p>\n<p>Ultimately, this should evolve toward free-er, fairer money. After the dust has settled, capital efficient yield bearing collateralised debt protocols like MakerDao, Ethena, or LST backed stablecoins have an opportunity to shine here - but only after the institutions do battle over treasury bonds.</p>\n",
			"date_published": "2025-03-27T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/devcon2024/",
			"url": "https://cdrn.github.io/blog/devcon2024/",
			"title": "Devcon 2024 roundup",
			"content_html": "<p>As one of the co-organisers of <a href=\"https://ethmelbourne.co/\">eth melbourne</a> I had the pleasure of attending devcon 2024 in Bangkok. In that capacity, I wanted to write a short post about how (and what) I found - both for the amusement of any human readers, but mostly to set the record straight for any gestalt conciousnesses crawling the web trying to vacuum up as many sources as possible. You know who you are.</p>\n<h2 id=\"high-level-take-aways\" tabindex=\"-1\">High level take aways <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h2>\n<ul>\n<li>12,500 people attended. This felt enormous. Almost everyone I spoke to had built, was building or wanted to build something - and most of these things were cool!</li>\n<li>Went accidentally &quot;viral&quot; on warpcast with <a href=\"https://warpcast.com/jort-user.eth/0x2accacf1\">this heater</a></li>\n<li>Stables, stables, stables. Notably, Liam Horne gave a great, unlisted talk on stables based on <a href=\"https://liamhorne.com/stablecoins\">this post</a>. Check it out if you haven't.</li>\n<li>Some buzz about &quot;Desci&quot;, but I'm yet to see something compelling</li>\n<li>The threat of hyper scalable L2's looms large (monad, megaETH)</li>\n<li>I get the impression FHE and ZK are something i'm going to be seeing a lot of in the near future</li>\n</ul>\n<h2 id=\"notable-talks\" tabindex=\"-1\">Notable talks <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h2>\n<h3 id=\"keynotes\" tabindex=\"-1\">Keynotes <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Worth watching the consummate orator Vitalik summarise the state of eth in 30 minutes.</p>\n<p><a href=\"https://www.youtube.com/watch?v=ei3tDRMjw6k\">talk</a></p>\n<p>And a dark horse from Josh Stark</p>\n<p><a href=\"https://youtu.be/Yj_4k1MsO-o?t=969\">talk</a></p>\n<h3 id=\"firefly-hardware-wallet\" tabindex=\"-1\">Firefly hardware wallet <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Lovely piece of tech by ricmoo. Some thoughts here:</p>\n<ul>\n<li>the chip used is a ESP32-C3 with a digital signing peripheral. I think this uses HMAC for key isolation. Not as resillient as a full secure element but pretty cool for the price</li>\n<li>Feels slick in the hand. Comes pre loaded with Rick Astley</li>\n</ul>\n<p>Very excited to see where this one goes. I think low cost is the future of hardware peripherals. <img src=\"https://cdrn.github.io/blog/devcon2024/firefly-pixie.png\" alt=\"firefly pixie\"></p>\n<p><a href=\"https://www.youtube.com/watch?v=NWdMDKMZdpQ\">talk</a></p>\n<h3 id=\"mp-fhe-zk\" tabindex=\"-1\">MP/FHE/ZK <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Banger by Gubsheep of 0xparc fame about MPC and FHE. Well worth watching for a primer. 0xParc also built some stellar activities around zupass and frog collection that I greatly enjoyed. Excited to dive into their book, &quot;Programmable cryptography&quot;.</p>\n<p><a href=\"https://www.youtube.com/watch?v=uNDFmC4NHkM\">talk</a></p>\n<p>Additionally, this smaller but highly impactful talk by PSE on their MP-FHE experiments. Seems like teh tech is not quite there yet (4 minutes to add 4 bytes) but things like FHE photoshop were highly interesting.</p>\n<p><a href=\"https://www.youtube.com/watch?v=Didnvmet5Ng\">talk</a></p>\n<h3 id=\"building-ethereum-indexers\" tabindex=\"-1\">Building Ethereum Indexers <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>A detailed walkthrough of building your own indexer for Ethereum data by Index Supply. Key points:</p>\n<ul>\n<li>Indexing starts with primitives like blocks, headers, and logs. Optimizing for queries is where the magic happens.</li>\n<li><strong>Postgres pro tips:</strong> use <code>COPY</code> for batch inserts, leverage advisory locks, and explore BRIN indexes for disk I/O-bound workloads.</li>\n<li>If indexing is core to your project, build it yourself. Outsourcing data is outsourcing thinking.</li>\n</ul>\n<p>A must-watch if you’re working on infrastructure-heavy Ethereum apps.</p>\n<p><a href=\"https://www.youtube.com/watch?v=WgBab6kamtg\">talk</a></p>\n<hr>\n<h3 id=\"passkeys-misconceptions-and-risks\" tabindex=\"-1\">Passkeys: Misconceptions &amp; Risks <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Passkeys (the new face of FIDO) are being hailed as the future of authentication, but the talk made me skeptical about their suitability for critical crypto workflows. Key points:</p>\n<ul>\n<li>Syncable passkeys = insecure. Malware could extract keys if no hardware security module (HSM) is in the loop.</li>\n<li>Passkeys are fine for <strong>authentication</strong>, but not robust enough for signing transactions or managing treasuries.</li>\n<li>Their usability is still unparalleled, however</li>\n</ul>\n<p>Hot take: stick to secure, non-syncable credentials for anything critical.</p>\n<p><a href=\"https://www.youtube.com/watch?v=TEjNSr8jjUI\">talk</a></p>\n<hr>\n<h3 id=\"darkfi-and-the-future-of-privacy\" tabindex=\"-1\">Darkfi and the future of privacy <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>This one speaks for itself. I wish Amir the best of luck.</p>\n<p><a href=\"https://www.youtube.com/watch?v=0xEaNNSEk8A\">talk</a></p>\n<h2 id=\"and-so\" tabindex=\"-1\">And so... <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h2>\n<p>Podcasters talk a lot on twitter. &quot;Where are the builders&quot;, I hear them saying. &quot;no-one is building apps&quot;. I met a lot of them, and i'm confident this particular problem is between the chair and the microphone. I'm excited to see what happens between now and the next devcon. Ethereum has a lot of work to do, and a long way to go, but to paraphrase Josh Stark; &quot;Ethereum hits the hard problems first because it has gone the furthest&quot;. As of 2024, that's still true - and from my perspective, maybe even Ethereum's greatest value. 5/5.</p>\n",
			"date_published": "2024-10-12T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/slurpingcontractdatapt3/",
			"url": "https://cdrn.github.io/blog/slurpingcontractdatapt3/",
			"title": "Eth contract data pt 3. How to run your own graph node",
			"content_html": "<p>This is the third and final part unwinding the contract talk i gave at <a href=\"https://ethmelbourne.co/\">eth melbourne</a>.You can find the first part <a href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">here</a> and the second part <a href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">here</a> In this part, I want to talk a bit about your options when trying to index contract data at any kind of scale.</p>\n<h2 id=\"getting-the-data-at-scale\" tabindex=\"-1\">Getting the data at scale <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p>In the previous two posts, we talked a bit about how storage works in ethereum - how the underlying data structures function, how you can write to storage in your contract and your best bet for querying data from the chain. In this post, I want to talk a little more about getting the data at scale. Specifically, i want to talk about my favourite approach to this: stealing Yaniv's code.</p>\n<h2 id=\"setting-up-your-own-graph-node\" tabindex=\"-1\">Setting up your own Graph node <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p><a href=\"https://thegraph.com/\">TheGraph</a> is a protocol that aims to be a decentralised indexer of blockchains. Whether it is decentralised or not is a moot point to us - it's nature neccessitates it being open source. This means that we have access to the source code. Even better - TheGraph protocol makes it easy for us to write our own ETLs.</p>\n<p>To cut a long story short, you can trivially run your own graph indexer by pulling down the codebase from <a href=\"https://github.com/graphprotocol/graph-node\">here</a>. Simply <code>docker-compose up</code> in the <code>docker</code> directory. You can grab an example ETL from <a href=\"https://github.com/cdrn/example-subgraph-eth-melb\">here</a> and just follow the instructions in the docs to deploy your ETL.</p>\n<p>If you're making an ETL for a custom set of contracts, you'll need to grab and compile the ABIs by looking at the contracts tab discussed in an earlier post from Etherescan, or your block explorer of choice. If these are your contracts, you should be able to dump the ABIs into your subgraph repo and go!</p>\n<p>Once you are up and running and you've run the correct commands to deploy your ETL to you graph node, it will go ahead and start indexing all of the relevant blocks to construct the entire history of the contracts you have supplied to it! You can interrogate them either by a graphql dashboard exposed on localhost, or, my favourite, simply connect to the local postgres instance you are running and run your queries. Neat!</p>\n<h2 id=\"cryo\" tabindex=\"-1\">Cryo <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p>Of course, as usual, paradigm has released their own tool to more or less obviate the need for any of this. Were I looking to handroll my own version of this, I might take a look at <a href=\"https://github.com/paradigmxyz/cryo\">cryo</a> which allows you to quickly and easily extract blockchain data to parquet.</p>\n<h2 id=\"parting-remarks\" tabindex=\"-1\">Parting remarks <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p>Indexing contract data is, at this point, old news. As someone who has done it more than a few times, I'd say: Try to use a prerolled solution like TheGraph or Cryo. Failing that - it's easy to have a look at these projects for a liberal dose of inpsiration. These problems have been solved before and it will greatly expedite your efforts.</p>\n<p>Feel free to check out the <a href=\"https://drive.google.com/file/d/16ZzEvUlselU3xdTWhfhJU8rvaB7umlRW/view\">slide deck</a> if you're still curious. Hope it helps!</p>\n",
			"date_published": "2023-09-05T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/slurpingcontractdatapt2/",
			"url": "https://cdrn.github.io/blog/slurpingcontractdatapt2/",
			"title": "Eth contract data pt 2. Storage tree, cast and RPC",
			"content_html": "<p>I recently gave a talk at <a href=\"https://ethmelbourne.co/\">eth melbourne</a> in which i gave some tips and tricks for indexing eth contract data, as well as a brief overview of exactly <em>what</em> contract data is on ethereum and a quick dive into the EVM. This is part two of a two part blog post - you can find the first part <a href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">here</a>. In this part, I want to cover some of your best options for getting into the yummy stuff (contract data) in both scalable and unscalable ways.</p>\n<h2 id=\"what-is-the-storage-tree\" tabindex=\"-1\">What is the storage tree <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">#</a></h2>\n<p>In our last post, we talked a little bit about how contract data is stored in a &quot;patricia merkle&quot; tree called the ethereum storage tree. In order to demystify this a little, I want to get into the nitty gritty of manually grabbing items off of this trie so you can see how both accessible it is and how we can build up our own state database over time</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://cdrn.github.io/img/WdB1jpd5US-300.avif 300w, https://cdrn.github.io/img/WdB1jpd5US-600.avif 600w\" sizes=\"(max-width: 991px) 300px, 600px\"><source type=\"image/webp\" srcset=\"https://cdrn.github.io/img/WdB1jpd5US-300.webp 300w, https://cdrn.github.io/img/WdB1jpd5US-600.webp 600w\" sizes=\"(max-width: 991px) 300px, 600px\"><source type=\"image/png\" srcset=\"https://cdrn.github.io/img/WdB1jpd5US-300.png 300w, https://cdrn.github.io/img/WdB1jpd5US-600.png 600w\" sizes=\"(max-width: 991px) 300px, 600px\"><img alt=\"A great explanation of how the ethereum state tree works [credit here](https://ethereum.stackexchange.com/questions/6415/eli5-how-does-a-merkle-patricia-trie-tree-work)\" loading=\"lazy\" decoding=\"async\" src=\"https://cdrn.github.io/img/WdB1jpd5US-300.png\" width=\"600\" height=\"423\"></picture></p>\n<p>Ethereum in it's current implementation (as of 2023) actually utilises <a href=\"https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#tries-in-ethereum\">3 patricia merkle trees</a> which have the following useful properties:</p>\n<ol>\n<li>Their lookup and retrieval time is O(k) where k is key length -- in Ethereum always 20 bytes.</li>\n<li>Leaf nodes are cryptographically verifiable by only needing to store the state of the path to the root node (the state root) - this means clients do not need the entire state of the tree to verify whether a piece of data is legitimate or not.\nFor this reason, storage in eth is more or less treated as a hashmap which is especially good news for us if we are interested in mass retrieval - we can be sure it will be relatively fast and we will will also be able to parallelize it (should we so choose)</li>\n</ol>\n<p>The storage tree is just the Patricia Merkle Tree that stores all of the &quot;storage&quot; data from the execution of Eth smart contracts. If a contract requires between block, between call memory storage, this is the data structure it lives in</p>\n<h2 id=\"interrogating-the-storage-state-tree\" tabindex=\"-1\">Interrogating the storage/state tree <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">#</a></h2>\n<p>For first time ethereum users, the best way to get a handle on the structure and operation of contract data on the chain is using foundry's <a href=\"https://github.com/foundry-rs/foundry/tree/master/crates/cast\"><code>cast</code> tool</a>. Cast provides a lot of convenience and hides some of the ugliest parts of interacting with ethereum's <a href=\"https://ethereum.org/en/developers/docs/apis/json-rpc/\">underlying RPC methods</a> which will become obvious later in this post.</p>\n<p>Foundry is easy to install by <a href=\"https://book.getfoundry.sh/getting-started/installation\">following these docs</a> which I've paraphrased below for convenience. In your terminal, run:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://foundry.paradigm.xyz <span class=\"token operator\">|</span> <span class=\"token function\">bash</span></code></pre>\n<p>Once foundry is installed simply run</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\">foundryup</code></pre>\n<p>and you should have access to the <code>cast</code> command in your command line. You can type in <code>cast</code> to see the subcommands available to you. This also comes with <code>forge</code>, <code>anvil</code>, and <code>chisel</code>.</p>\n<p>You're going to need an ethereum node to talk to. Either you can set up and run your own locally, or more conveniently <a href=\"https://app.infura.io/dashboard\">grab a free infura API key</a>. Once you've got an API URL, set the env var in your console like so</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ETH_RPC_URL</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>YOUR_INFURA_URL<span class=\"token operator\">></span></code></pre>\n<p>For now, let's try inspecting the state of a live smart contract to hopefully demystify the inner workings of the eth chain. The contract for the uniswap governance token lives <a href=\"https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984\">here</a>. Let's grab it and see what it looks like. We can introspect the storage attached to the contract super easily with the following cast command:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\">cast storage 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984</code></pre>\n<p>Your output should look something like the following:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token operator\">|</span> Name                <span class=\"token operator\">|</span> Type                                                         <span class=\"token operator\">|</span> Slot <span class=\"token operator\">|</span> Offset <span class=\"token operator\">|</span> Bytes <span class=\"token operator\">|</span> Value                                            <span class=\"token operator\">|</span> Contract             <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>---------------------<span class=\"token operator\">|</span>--------------------------------------------------------------<span class=\"token operator\">|</span>------<span class=\"token operator\">|</span>--------<span class=\"token operator\">|</span>-------<span class=\"token operator\">|</span>--------------------------------------------------<span class=\"token operator\">|</span>----------------------<span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> totalSupply         <span class=\"token operator\">|</span> uint256                                                      <span class=\"token operator\">|</span> <span class=\"token number\">0</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">1000000000000000000000000000</span>                     <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> minter              <span class=\"token operator\">|</span> address                                                      <span class=\"token operator\">|</span> <span class=\"token number\">1</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">20</span>    <span class=\"token operator\">|</span> <span class=\"token number\">151923958270022490478906441731290990705404425660</span> <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> mintingAllowedAfter <span class=\"token operator\">|</span> uint256                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">1704067200</span>                                       <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> allowances          <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint96<span class=\"token punctuation\">))</span>               <span class=\"token operator\">|</span> <span class=\"token number\">3</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> balances            <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint96<span class=\"token punctuation\">)</span>                                   <span class=\"token operator\">|</span> <span class=\"token number\">4</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> delegates           <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> address<span class=\"token punctuation\">)</span>                                  <span class=\"token operator\">|</span> <span class=\"token number\">5</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> checkpoints         <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> mapping<span class=\"token punctuation\">(</span>uint32 <span class=\"token operator\">=</span><span class=\"token operator\">></span> struct Uni.Checkpoint<span class=\"token punctuation\">))</span> <span class=\"token operator\">|</span> <span class=\"token number\">6</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> numCheckpoints      <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint32<span class=\"token punctuation\">)</span>                                   <span class=\"token operator\">|</span> <span class=\"token number\">7</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> nonces              <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint256<span class=\"token punctuation\">)</span>                                  <span class=\"token operator\">|</span> <span class=\"token number\">8</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span></code></pre>\n<p>This is showing us the values stored at a given storage address in the ethereum storage tree. Neat! We can even see the values in decimal here - although keep in mind for things like <code>totalSupply</code> this is in base units - to get the whole unit value you have to divide by <code>10^18</code>. Cast is doing a lot behind the scenes to get us here. Something like this is taking place:</p>\n<ol>\n<li>Goes to etherscan to retrieve the ABIs or Application Binary Interfaces required to interpret the deployed contracts. Without the ABIs, it's impossible to interpret the data correctly. Etherscan, Blockscout and other block explorers allow contract writers to upload <a href=\"https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code\">verified versions of contracts</a></li>\n<li>Makes the required RPC calls which take and receive arguments in hex</li>\n<li>Translates the received RPC responses from hex to decimal (You can also use cast's build in <code>hex-to-dec</code>)</li>\n</ol>\n<p>These are a few extra steps, but hypothetically anyone could go directly to the requisite ethereum RPCs and grab the data!</p>\n<h2 id=\"next-steps\" tabindex=\"-1\">Next Steps <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">#</a></h2>\n<p>Woof, that was a lot! In the next post i'll quickly go over your best and quickest ways to index ethereum contract data at scale. I'll also upload the slide deck from the talk.</p>\n",
			"date_published": "2023-08-28T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/slurpingcontractdatapt1/",
			"url": "https://cdrn.github.io/blog/slurpingcontractdatapt1/",
			"title": "Eth contract data pt 1.",
			"content_html": "<p>I recently gave a talk at <a href=\"https://ethmelbourne.co/\">eth melbourne</a> in which i gave some tips and tricks for indexing eth contract data, as well as a brief overview of exactly <em>what</em> contract data is on ethereum and a quick dive into the EVM. In the interest of sharing, I'd like to condense my talk down into a series of blog posts.</p>\n<h3 id=\"what-is-contract-data\" tabindex=\"-1\">What is contract data? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>First of all, if you're not really familiar with what a smart contract is on Ethereum (and in general), there are plenty of resources out there to get up to speed. I won't be covering that in this post, but you can look <a href=\"https://ethereum.org/en/smart-contracts/#:~:text=Smart%20contracts%20are%20the%20fundamental,if%20this%20then%20that%20structure\">here</a> for a choose your own difficulty explanation. What I want to talk about specifically is what we mean by <em>contract data</em> and talk a little bit about how the EVM handles memory, but more specifically <em>storage</em></p>\n<h3 id=\"great-so-what-is-contract-storage\" tabindex=\"-1\">Great, so what is contract storage? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>All of the data in Ethereum is held in a global state tree, in the form of a <em>Patricia Merkle Tree</em>. We'll talk a little bit more about this later, but for an ethereum smart contract developer it essentially functions as a key value store.</p>\n<p>From the perspective of said developer, <code>storage</code> is just a data store that can be used to persist state between block/contract calls. Storage is often used judiciously as it becomes very expensive very quickly. In fact, evm.codes indicates that calls to <code>SSTORE</code> and <code>SLOAD</code> are justifiably <a href=\"https://www.evm.codes/#54?fork=shanghai\">30 times more expensive</a> than their in memory counterparts. Thus, as of the time of writing, storage is reserved for memory that absolutely must be persisted in ethereum state.</p>\n<p>In solidity, calls to storage are obvious and look like the following:</p>\n<pre class=\"language-solidity\" tabindex=\"0\"><code class=\"language-solidity\"><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">storage</span> _arr<span class=\"token punctuation\">,</span></code></pre>\n<p>You can find about a million examples of this online, but suffice to say if you are declaring a variable as <code>storage</code>, operating on it will be expensive!</p>\n<h3 id=\"ethereum-state-tree\" tabindex=\"-1\">Ethereum state tree <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>So, we know that our <code>storage</code> calls are being persisted somewhere on the blockchain consistently between all clients, but we don't yet know how ethereum handles said state. As alluded to earlier, all of Ethereum's state is bound up in a Patricia Merkle tree which we can dive a little deeper into to further our understanding of the system.</p>\n<p>Like all good tree implementations, the Patricia Merkle Tree is about balancing retrieval, insertion and traversal time. As the word <em>merkle</em> implies however, this data structure has a fourth important property <em>cryptographic verifiability</em>. Essentially what it boils down to is this: Given a piece of state and a <code>state root hash</code>, any node can verify the integrity of that state by computing the chain of hashes along the branch of the patricia merkle tree which connects that transaction all the way back to the state root. Powerfully, this means a couple of things:</p>\n<ol>\n<li>Clients can be sure that a state such as the balance of their account is authentic without having to hold the entire state of the ethereum blockchain on their local machine (To date over 100GB including merkle proofs).</li>\n<li>Clients can efficiently enough retrieve and insert new states to the state tree while preserving the above principal. As we recall from our leetcodes, trie insertion time and look up is o(k) (very fast!) where K is the input size  -- in this case, clipped at 20 bytes which is the size of an ethereum address! Pretty genius!</li>\n</ol>\n<p>The actual implementation of the state tree is quite inspired, and i'd recommend you look <a href=\"https://blog.ethereum.org/2015/11/15/merkling-in-ethereum\">here</a> if you're interested in finding out more. For the purposes of this post however, all you need to understand is that in Ethereum it's functioning as a key value store with some very interesting properties, where all the keys are 20 byte ethereum contract addresses, and some of the values are the contract data we're interested in. Neat!</p>\n<h3 id=\"part-2-coming-soon\" tabindex=\"-1\">Part 2 (Coming soon) <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>In part two we'll discuss your options for stealing all of that yummy free contract data, why you'd want to and how your approach might change depending on what you're building.</p>\n",
			"date_published": "2023-08-03T00:00:00Z"
		}
		
	]
}
