{
	"version": "https://jsonfeed.org/version/1.1",
	"title": "Chris Doran",
	"language": "en",
	"home_page_url": "https://cdrn.github.io/",
	"feed_url": "https://cdrn.github.io/feed/feed.json",
	"description": "bl√∂g",
	"author": {
		"name": "Chris",
		"url": "https://cdrn.github.io/about-me/"
	},
	"items": [
		{
			"id": "https://cdrn.github.io/blog/gauloi-pt2/",
			"url": "https://cdrn.github.io/blog/gauloi-pt2/",
			"title": "Gauloi Part 2: mechanism design",
			"content_html": "<h2 id=\"1-preamble\" tabindex=\"-1\">1. Preamble <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p><a href=\"https://cdrn.xyz/blog/gauloi/\">Part 1</a> covered what Gauloi is and why it exists. Intent-based cross-chain stablecoin settlement, compliance at the maker level, optimistic finality. The architecture post.</p>\n<p>This post is about how it actually works. The escrow state machine, the dispute mechanism, the settlement window, the edge cases. Some of this is settled. Some of it isn't, and I'll say so where that's the case.</p>\n<h2 id=\"2-the-escrow-state-machine\" tabindex=\"-1\">2. The escrow state machine <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>Everything starts with an escrow contract on the source chain. The taker locks funds, the protocol coordinates the fill, and the escrow releases once settlement finalises.</p>\n<p>The lifecycle has six states. A taker deposits into the escrow with their intent parameters (output token, destination chain, destination address, minimum amount, expiry) and the intent goes OPEN. A maker commits on-chain, reserving the intent so nobody else can front-run the fill - this adds a gas cost but prevents two makers from racing to fill the same intent. The maker then has N blocks to fill before the commitment expires and the intent reopens.</p>\n<p>Once the maker has sent the correct token to the taker's destination address on chain B, they submit a claim to the escrow on chain A with the destination tx hash. This moves the intent to FILLED and starts the dispute window. If the window passes without a challenge, the escrow releases the taker's deposit to the maker. If someone disputes, it escalates to the staked maker set for resolution. If no maker ever commits, or a committed maker doesn't fill in time, the taker reclaims their deposit.</p>\n<p>The on-chain footprint in the happy path is two to three transactions: taker deposits, maker commits, maker claims. The fill itself happens on chain B and only touches chain A when the maker submits evidence.</p>\n<p>The contract interface looks roughly like this:</p>\n<pre class=\"language-solidity\" tabindex=\"0\"><code class=\"language-solidity\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">IntentState</span> <span class=\"token punctuation\">{</span> Open<span class=\"token punctuation\">,</span> Committed<span class=\"token punctuation\">,</span> Filled<span class=\"token punctuation\">,</span> Settled<span class=\"token punctuation\">,</span> Disputed<span class=\"token punctuation\">,</span> Expired <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Intent</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">address</span> taker<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">address</span> inputToken<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint256</span> inputAmount<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint256</span> destinationChain<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">address</span> destinationAddress<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">address</span> outputToken<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint256</span> minOutputAmount<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint256</span> expiry<span class=\"token punctuation\">;</span>\n    IntentState state<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">address</span> maker<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">bytes32</span> fillTxHash<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint256</span> disputeWindowEnd<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// --- Maker staking ---</span>\n\n<span class=\"token comment\">// Maker deposits stake to join the network.</span>\n<span class=\"token comment\">// Stake token set at deployment (see open questions).</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">stake</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Maker withdraws stake. Subject to cooldown</span>\n<span class=\"token comment\">// to prevent unstaking immediately after a fraudulent fill.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">unstake</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// --- Intent lifecycle ---</span>\n\n<span class=\"token comment\">// Taker approves inputToken first, then calls this.</span>\n<span class=\"token comment\">// Transfers inputAmount of inputToken into escrow.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createIntent</span><span class=\"token punctuation\">(</span>\n    <span class=\"token builtin\">address</span> inputToken<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">uint256</span> inputAmount<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">address</span> outputToken<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">uint256</span> minOutputAmount<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">uint256</span> destinationChain<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">address</span> destinationAddress<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">uint256</span> expiry\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> intentId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Staked maker reserves an intent. Reverts if caller</span>\n<span class=\"token comment\">// has insufficient stake for the fill amount.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">commitToIntent</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> intentId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Maker submits evidence of fill on destination chain.</span>\n<span class=\"token comment\">// Starts the dispute window.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">submitFill</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> intentId<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bytes32</span> destinationTxHash<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Anyone can call after dispute window expires</span>\n<span class=\"token comment\">// with no active dispute. Releases escrow to maker.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">settle</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> intentId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Taker reclaims deposit if intent expired</span>\n<span class=\"token comment\">// or committed maker failed to fill in time.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">reclaimExpired</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> intentId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// --- Disputes ---</span>\n\n<span class=\"token comment\">// Any staked maker can challenge a fill claim.</span>\n<span class=\"token comment\">// Bond amount calculated from fill size, transferred from caller.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">dispute</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> intentId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Staked makers submit attestations to resolve a dispute.</span>\n<span class=\"token comment\">// M/N threshold of signatures triggers resolution.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">resolveDispute</span><span class=\"token punctuation\">(</span>\n    <span class=\"token builtin\">bytes32</span> intentId<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">bool</span> fillValid<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">bytes</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">calldata</span> signatures\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Not final, but this is the shape of it.</p>\n<h2 id=\"3-the-dispute-mechanism\" tabindex=\"-1\">3. The dispute mechanism <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>Stablecoin settlement disputes are objectively resolvable. The question is always: did the maker send X amount of token Y to address Z on chain B? That's a binary lookup. The transaction either exists with the right parameters or it doesn't. Verifiable by anyone with an RPC endpoint.</p>\n<p>The system uses a single honest challenger model. This is the same security assumption as optimistic rollups - Optimism posts state roots to L1 and assumes they're valid, and anyone can submit a fraud proof within the dispute window. The system doesn't need every validator to check every state root. It just needs one honest watcher. If nobody challenges, the state root finalises. If even one participant catches fraud, the system self-corrects.</p>\n<p>Gauloi works the same way. Maker submits fill evidence and the claim is assumed valid by default. Settlement finalises automatically after the dispute window unless someone challenges. Any staked maker can raise a dispute by posting a bond. You only need one honest participant watching the network to catch fraud.</p>\n<p>Why this works particularly well for stablecoin settlement: verification is cheap (checking a tx hash is a single RPC call, so staked makers can passively monitor every fill without it being a burden), fraud is obvious (a fake tx hash either doesn't exist or has the wrong parameters, there's no ambiguity), and challengers are economically motivated (catch a fraudulent fill, get rewarded from the fraudulent maker's slashed stake).</p>\n<p>In the happy path, nothing happens. Maker claims, window passes, escrow releases. The dispute infrastructure exists but never activates. This solves the incentive problem of &quot;how do you pay attestors when disputes are rare&quot; - you don't need to, because active attestation isn't required for normal operation. The system only activates under adversarial conditions.</p>\n<p>When a dispute is raised, the staked maker set resolves it. Each participating maker independently checks the claimed transaction on chain B and signs an attestation. A threshold of M/N signatures resolves the dispute on-chain - the escrow contract verifies the threshold and either releases funds to the maker (claim valid, disputer's bond slashed) or returns funds to the taker (claim invalid, maker's stake slashed).</p>\n<p>Resolution should be fast. For EVM chains where you're checking a tx hash against an RPC, minutes not hours. The dispute window itself is longer than resolution time to give people time to notice, but the actual resolution once triggered should be near-instant.</p>\n<h2 id=\"4-staked-makers-as-the-attestor-set\" tabindex=\"-1\">4. Staked makers as the attestor set <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>Every maker stakes capital to join the network. The stake does triple duty: it gates participation (prevents sybil attacks), limits the maker's maximum active fill exposure (stake 500k, fill up to some multiple of that concurrently), and backs their attestations during dispute resolution (incorrect attestation = slashing). The same capital that lets them make markets also backs the integrity of the dispute mechanism.</p>\n<p>This avoids introducing a separate class of participant. The people verifying fills are the same people doing fills. They already have the infrastructure (watching multiple chains, monitoring cross-chain state), they already have economic alignment (their own fills depend on the system being trustworthy), and they already have capital at risk.</p>\n<p>The collusion question: what stops the staked makers from all agreeing to approve each other's fraudulent fills? Staked capital should be large enough that the cost of getting caught exceeds the one-time gain from fraud - the slashing penalty is the maker's entire stake, not just a portion, so a maker with 500k staked who tries to steal 100k risks the full 500k. As the maker set grows, coordinating collusion among independent economic actors becomes harder. And reputationally, makers operating in the compliant stablecoin space are likely to be known entities with businesses and regulatory exposure - the kind of participants for whom getting caught colluding is existentially bad, not just expensive.</p>\n<p>Early on when the maker set is small (say, 3-5 makers), the collusion risk is real and the honest answer is that you're relying on a small group of known, staked participants to be honest. This is roughly equivalent to trusting a multisig - which is exactly the thing Gauloi v1 was trying to avoid. The difference is that the trust assumption shrinks as the network grows, the participants have ongoing economic skin in the game rather than just key custody, and the stakes are denominated in the thing they'd have to steal (stablecoins) rather than in some governance token with detached incentives.</p>\n<p>I want to explicitly avoid a governance token for attestor selection. The design works with economic incentives and reputation. Token voting is a rug pull factory and I don't want it anywhere near the settlement layer.</p>\n<h2 id=\"5-the-settlement-window\" tabindex=\"-1\">5. The settlement window <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>How long should the dispute window be?</p>\n<p>It depends on the chain pair. The window needs to be long enough that the maker's fill on chain B is actually final, watchers have time to notice and dispute a fraudulent claim, and the maker set can respond if a dispute is raised.</p>\n<p>For EVM L2s (Arbitrum, Base, Optimism) with fast soft finality, the fill confirms in seconds. But L2 finality is complicated. Soft confirmation from the sequencer is fast but technically reversible if the sequencer goes rogue. Hard finality (posted to L1) takes longer - minutes to hours depending on the L2. And for optimistic rollups, the fraud proof window is 7 days, though in practice state roots are almost never challenged.</p>\n<p>So which finality do you target? If you wait for full L1 finality on every fill, your settlement window is hours to days and capital efficiency dies. If you accept sequencer soft confirmation, you get fast settlement but take on the (small, theoretical) risk that the sequencer reverses the fill.</p>\n<p>My current thinking is to let makers price this. Define chain-specific minimum settlement windows based on reasonable finality assumptions - maybe 30 minutes for Arbitrum/Base (well past soft confirmation, short of L1 finality), 15 minutes for Ethereum mainnet (sufficient block depth), and longer for chains with weaker finality. Makers who fill on chains with longer windows price the capital lockup into their spread. The protocol sets the floor, the market sets the ceiling.</p>\n<p>The interesting edge case: what happens if a fill on chain B gets reorged <em>after</em> the settlement window closes and the escrow has already released? The taker's deposit is gone. The maker's fill evaporated. Someone lost money. The honest answer is that this is a chain-level failure, not a protocol-level failure, and whoever took the finality risk (the maker) eats the loss. This is the same risk every bridge takes. You can mitigate it by being conservative with settlement windows per chain, but you can't eliminate it without waiting for true L1 finality everywhere, which makes the system unusable.</p>\n<p>For stablecoins, this risk is at least bounded. A reorged fill on a 1:1 stablecoin pair means the maker lost approximately the face value. No directional blowup. A maker can quantify this risk per chain and reserve against it.</p>\n<h2 id=\"6-bond-economics\" tabindex=\"-1\">6. Bond economics <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>There are two bonds in the system: the maker's stake and the dispute bond. They serve different purposes and price different attacks.</p>\n<p>The maker's stake is a standing bond. Posted once when the maker joins, stays locked while they're active. It limits concurrent fill exposure, backs attestation, and is the slashing target for fraud. The standing model is more capital efficient than per-fill bonding - the maker posts once and executes many fills against the same stake, with the constraint on concurrent exposure rather than per-fill cost. Active makers turning over capital quickly amortise the bond cost across volume.</p>\n<p>The stake needs to be large enough that fraud is -EV. The expected value of attempting a fraudulent claim is <code>(1-P) * fill_amount - P * stake</code>, where P is the probability of getting caught. Given the single honest challenger assumption and the trivial verification cost, P should be very high. A stake of 2-5x the maximum fill size makes fraud unprofitable even with generous assumptions about getting away with it - a maker staking 500k who tries to steal 100k on a single fill risks the entire 500k.</p>\n<p>The dispute bond is posted by the challenger. It prevents spam - a troll disputing every claim pays the bond each time and loses it when the claim is valid. A legitimate challenger pays once, gets it back plus a reward from the fraudulent maker's slashed stake. Since dispute resolution is fast (minutes, a trivial RPC lookup) the damage from a spam dispute is limited, so the bond doesn't need to be extreme. Something like <code>max(0.5% of swap, 25 USDC)</code> - enough to make griefing unprofitable but low enough that real fraud gets challenged.</p>\n<p>These parameters need to be tunable. The contracts should support governance-free parameter updates through a timelock mechanism - no token voting.</p>\n<h2 id=\"7-extending-beyond-evm\" tabindex=\"-1\">7. Extending beyond EVM <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>Everything above assumes both chains are EVM-compatible. Transaction hashes look the same, RPC interfaces are standardised, the staked maker set knows how to verify a fill using the same tooling regardless of which EVM chain it's on.</p>\n<p>Tron is the obvious next step because it's where most USDT lives. Tron is mostly EVM-compatible at the API level so the dispute resolution model doesn't change much. The differences are in finality (DPoS with 27 super representatives, ~3 second blocks, 19-block finality around 57 seconds) and gas economics. The escrow contract would need a Tron-specific deployment (Solidity compiles to TVM with minor differences) but the dispute mechanism works the same way.</p>\n<p>Bitcoin is the hard case. No smart contracts in the EVM sense, no escrow contract, no on-chain state machine. Supporting BTC stablecoins would need either an intermediary chain to host the escrow or a UTXO-native escrow using Bitcoin Script - limited but possible for simple lock/release patterns. Later problem. Stablecoin volume is overwhelmingly EVM plus Tron.</p>\n<p>Solana is interesting because it has large USDC volume and a different execution model (accounts and programs, not contracts and storage). The dispute mechanism still works - a fill on Solana produces a transaction signature that any maker can verify. The gap is that Gauloi's contracts would need to be written in Rust, which doubles the audit surface. Worth doing eventually, not for v0.1.</p>\n<p>The general principle: the escrow and dispute mechanism should work for any chain pair where a staked maker can verify a transaction happened. The staked maker set is the abstraction layer - they translate &quot;did this fill happen on chain B&quot; into a signed attestation that the escrow on chain A can consume, regardless of what chain B looks like underneath.</p>\n<h2 id=\"8-open-questions\" tabindex=\"-1\">8. Open questions <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>There are things I haven't solved yet.</p>\n<p><strong>Maker collusion in early days.</strong> The economic argument against collusion improves with scale. With 3-5 makers, it's a trust assumption. With 50 staked makers, coordination is hard and one defector collapses the scheme. The bootstrap period is the most vulnerable and probably requires known, reputable initial makers who have more to lose from reputational damage than they could gain from fraud. This is imperfect. It might be the best available option for early-stage.</p>\n<p><strong>Intent ordering and MEV.</strong> If intents are posted on-chain, block builders see them before makers do. A malicious builder could front-run intents by inserting their own maker commitment before legitimate makers. For stablecoins with tight spreads this is less of an issue than for volatile pairs (not much to extract from front-running a 3 bps spread), but it's worth thinking about. Off-chain intent relay would solve this but adds infrastructure.</p>\n<p><strong>Multi-hop routes.</strong> The design above assumes single-hop: chain A to chain B. What about USDT on Tron to EURC on Ethereum where there's no direct maker? You'd need either a multi-hop route (Tron USDT to Arb USDC to Eth EURC) or a single maker capitalised on both ends. Multi-hop introduces sequential settlement dependencies and compounding failure risk. Probably better to let makers handle routing internally and just quote a single price for the end-to-end.</p>\n<p><strong>Regulatory classification.</strong> Is Gauloi an exchange? A clearinghouse? A money transmitter? The compliance-at-maker-level design is partly intended to push regulatory obligations to the participants rather than the protocol, but untested legal theory isn't the same as regulatory clarity. This needs real legal analysis, which I haven't done yet.</p>\n<p><strong>Stake denomination.</strong> Should the maker stake be in a specific stablecoin, in ETH, or in something else? Stablecoin-denominated stakes are cleanest (the system handles stablecoins, the stake is in stablecoins, no oracle needed for slashing calculations). But which stablecoin? USDC is the obvious choice for US-compliant makers, but it introduces an issuer dependency on the settlement layer itself. ETH-denominated stakes require a price oracle for calculating slashing relative to fill amounts. No clean answer here yet.</p>\n<h2 id=\"9-what-s-next\" tabindex=\"-1\">9. What's next <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi-pt2/\">#</a></h2>\n<p>Part 3 will probably be code. Escrow contracts for Arbitrum and Base, a basic maker bot, and enough infrastructure to prove the settlement loop works end to end. USDC/USDT, two chains, one maker. Boring and functional.</p>\n<p>If you've read both parts and have opinions on the staking model or the dispute economics, I'm genuinely interested. These are the hardest open problems and I'd rather get them right than ship something elegant that breaks under adversarial conditions.</p>\n<p>cdrn.xyz</p>\n",
			"date_published": "2026-02-11T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/gauloi/",
			"url": "https://cdrn.github.io/blog/gauloi/",
			"title": "Gauloi: compliant cross-chain settlement",
			"content_html": "<h2 id=\"1-preamble\" tabindex=\"-1\">1. Preamble <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p><img src=\"https://cdrn.github.io/blog/gauloi/gauloi.jpeg\" alt=\"Stone relief of a Phoenician gauloi - a round-hulled merchant vessel with a single square sail, carved in ancient Sidon\"></p>\n<p>A gauloi is a Phoenician trade cog - a round-hulled merchant ship that carried goods across the ancient world three thousand years ago. The Phoenicians ran the widest known trade network of their era - not just the Mediterranean but beyond: tin from Britain, gold from West Africa via Hanno's fleet down the Atlantic coast, and if you believe Herodotus, a full circumnavigation of Africa commissioned by Pharaoh Necho II two and a half millennia before Magellan. They connected economies that couldn't trade directly - Egypt, Greece, Carthage, Iberia, and beyond - through a network of neutral ports, standardised weights, and pragmatic indifference to who was on the other side of the trade. They didn't care about your god or your king. They cared about your cargo.</p>\n<p>I first designed Gauloi with <a href=\"https://github.com/0x330a\">0x330a</a>, drawing on my experience building cross-chain infrastructure at Chainflip. The <a href=\"https://nifty-novel-3d0.notion.site/Gauloi-overview-start-here-46c173bf028b42c985d7a6138d8d515e\">original</a> was an HTLC-based atomic swap protocol with a peer-to-peer marketplace - Kademlia routing, proof-of-work spam prevention, the works. We phased it Sidon, Tyre, Carthage after the Phoenician trade cities. The thesis was simple: there's no way to swap between Bitcoin and Ethereum reliably without delegating your funds to a multisig, and multisigs get hacked. Atomic swaps solve this. Peer to peer. No intermediaries. Your funds never leave your custody.</p>\n<p>That thesis was right. The mechanism was wrong. I'll explain why, what's changed, and where this needs to go.</p>\n<h2 id=\"2-what-was-wrong-with-v1\" tabindex=\"-1\">2. What was wrong with v1 <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>The original Gauloi used hashed time-locked contracts. HTLCs are elegant in theory: two parties lock funds on their respective chains, a shared hash locks both sides, revealing the preimage on one chain lets you claim on the other. Atomic. Trustless. No multisig.</p>\n<p>In practice, they have three problems that make them unusable as a spot market.</p>\n<p>First, the optionality problem. James Prestwich <a href=\"https://prestwi.ch\">wrote about this</a> extensively. In an HTLC swap, until funds are committed on both ends and the preimage is revealed, either party can back out. The worst case: your counterparty locks funds, you lock funds, and they simply... wait. They now hold a free option on the underlying asset for the duration of the timelock. Price moves in their favour? Complete the swap. Doesn't? Let it expire. You've given someone a free call option and locked your capital to do it.</p>\n<p>Second, the UX. Both parties must be online. Timelocks must be staggered across chains with different block times and finality guarantees. Reorgs can create race conditions where a preimage is revealed too close to expiry. You need watchtowers to enforce claims if you go offline. The surface area of things that can go wrong is large, and every edge case locks someone's funds for hours.</p>\n<p>Third, coincidence of wants. HTLCs don't have pools or passive liquidity - just two people who happen to want opposite sides of the same trade at the same time. Fine for large bilateral trades. Doesn't scale to a market.</p>\n<p>We knew these problems when we wrote the original spec. We thought reputation systems, spam prevention and market makers quoting implied volatility over the timelock window could patch them. They can't. The problems are structural to HTLCs, not incidental.</p>\n<p>Since then, the landscape shifted. Intent-based architectures emerged. The stablecoin market exploded. The compliance gap between what regulators demand and what on-chain infrastructure provides became a chasm. And the bridge wars proved that the <a href=\"https://cdrn.xyz/blog/bridgenotproduct/\">bridge is not the product</a> - the orderflow is.</p>\n<p>Gauloi v2 keeps the peer-to-peer ethos and drops the settlement primitive that made it unusable.</p>\n<h2 id=\"3-the-gap\" tabindex=\"-1\">3. The gap <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>I've written about these problems individually over the past year. Why stablecoin issuers will <a href=\"https://cdrn.xyz/blog/whatsgoingonstables/\">compete on yield</a> until the spread between money and t-bills trends toward zero. Why <code>blacklist()</code> <a href=\"https://cdrn.xyz/blog/speed-of-law-vs-blocks/\">catches static funds</a> and dumb attackers but can't touch anything that moves - 44 minutes to freeze an address that can exit in 12 seconds. Why bridges lost the value war to aggregators and solvers who own the orderflow.</p>\n<p>Here's where things stand. An institution wants to move $5M of USDT on Tron to USDC on Base. They can use a centralised exchange (slow, KYC friction, counterparty risk, fees), an OTC desk (phone call, trust someone, settle in hours), or a permissionless bridge (fast, but their compliance team vetoes it because the pool processed Lazarus funds last month). None of these are good.</p>\n<p>On the retail side it's more mundane but equally broken. User holds USDT because that's what their on-ramp gave them. The app they want takes USDC on Arbitrum. They need to find a bridge aggregator, pay gas on two chains, wait for finality, and hope the routing doesn't touch something sanctioned. Or just use a CEX. Most do.</p>\n<p>What's missing is a settlement layer that doesn't care which stablecoin you hold or which chain it's on, handles compliance at the participant level rather than the protocol level, and is cheap enough that makers can quote tight on what are essentially 1:1 swaps.</p>\n<h2 id=\"4-why-stablecoins\" tabindex=\"-1\">4. Why stablecoins <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>The original Gauloi was for BTC/ETH. Why narrow the scope?</p>\n<p>Volatile pairs are hard. The optionality problem from v1 doesn't go away just because you swap HTLCs for optimistic settlement - it changes shape. A maker filling a volatile cross-chain swap is taking directional risk for the duration of the settlement window, and that risk has to be priced into the spread. You end up competing with CEXs on execution quality, which is a losing game unless you have Citadel's infrastructure.</p>\n<p>Stablecoin pairs are different. USDC/USDT is not a trade, it's a transfer denominated in the same unit with different issuers on different rails. The &quot;price&quot; is 1:1 with minor deviations. Inventory risk is basis points. This means spreads can be tight enough that the compliance angle actually matters - when your spread is 3 bps, the difference between &quot;I screened this counterparty&quot; and &quot;I didn't&quot; is the whole margin.</p>\n<p>The other reason is that stablecoins are where the compliance problem is most acute. These are dollar instruments. Issuers have freeze functions. OFAC cares. The GENIUS Act is <a href=\"https://cdrn.xyz/blog/speed-of-law-vs-blocks/\">mandating capabilities</a> that structurally can't do what's asked of them. Institutions want to use stablecoins cross-chain but can't touch the existing rails. This is a compliance gap with real money behind it, not a theoretical one.</p>\n<p>And there's a market timing argument. An explosion of issuer-specific stablecoins is coming - every bank, every fintech, every payments company wants to issue one. For payments to actually work, they need to interoperate. Circle's <a href=\"https://www.circle.com/cross-chain-transfer-protocol\">CCTP</a> handles USDC-to-USDC across chains but it's a single-issuer solution, not a market. Nobody is building the neutral settlement layer for cross-stable, cross-chain flows with compliance that actually works. That's the gap.</p>\n<h2 id=\"5-the-architecture\" tabindex=\"-1\">5. The architecture <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>Gauloi is an intent-based cross-chain settlement protocol for stablecoins.</p>\n<p>A taker broadcasts an intent: &quot;I have 10,000 USDT on Tron. I want USDC on Base.&quot; Makers see the intent. Before quoting, they screen the taker's address - Chainalysis, TRM, Elliptic, whatever their compliance stack looks like. Clean address? They quote. Dirty? They walk away. The protocol doesn't make that call. The maker does.</p>\n<p>Settlement is optimistic. Best quote wins. The maker fills the taker on the destination chain and the system assumes the fill is valid unless someone disputes it. A dispute window opens. If no fraud proof lands before it closes, settlement finalises and the maker receives the taker's source funds.</p>\n<p>That's the loop. Intent, screen, quote, fill, settle.</p>\n<p>What matters here is what the protocol <em>doesn't</em> do. The protocol has no opinion on compliance - it just coordinates and settles. Makers are the ones with capital deployed, with reputations, with regulatory exposure, so they make the compliance call. This is how market making works in tradfi. It should work this way on-chain too.</p>\n<p>The other thing that matters is that the maker sees the counterparty before committing capital. This is impossible on an AMM. A Uniswap pool can't tell if the next swap is from Coinbase or Lazarus. Intent-based systems expose the taker at quote time. Compliance isn't bolted on after the fact - it's native to the flow. The quote <em>is</em> the compliance decision.</p>\n<p>Settlement being optimistic rather than atomic is the key evolution from v1. Instead of locking liquidity on both chains and playing the HTLC timeout game, the maker just fills and trusts the system to release source funds after the dispute window. It's more capital efficient, better UX, and you don't hand your counterparty a free option. The tradeoff is finality risk during the settlement window, but for stablecoin pairs with minimal volatility, that risk is small and priceable.</p>\n<p>If this sounds like <a href=\"https://across.to\">Across</a>, it should. Across pioneered intent-based optimistic settlement for cross-chain transfers, using UMA's oracle for dispute resolution with a 60-minute batch window. It works. But Across is a general purpose bridge with permissionless relayers - anyone can fill, there's no screening, and the protocol makes no distinction between a Coinbase treasury wallet and a Lazarus proxy. That's fine for ETH and general token transfers where compliance is someone else's problem. It's not fine for stablecoins, where the issuer has a freeze function and the regulator has an opinion. Gauloi takes the intent-plus-optimistic-settlement model and makes compliance native to the quote flow. The maker screens before filling. The protocol stays neutral but the participants aren't anonymous to each other. Same settlement guarantees, different trust model at the edges.</p>\n<h2 id=\"6-compliance-as-a-market-function\" tabindex=\"-1\">6. Compliance as a market function <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>The standard approach to on-chain compliance is access control. Whitelist addresses, blacklist addresses, freeze at the contract level. I've <a href=\"https://cdrn.xyz/blog/speed-of-law-vs-blocks/\">argued before</a> that this is structurally broken - too slow, too blunt, trivially routed around by anyone who understands the asset model.</p>\n<p>Gauloi does something different. Compliance is a market function, not a protocol function.</p>\n<p>Each maker runs their own compliance stack. Some screen with Chainalysis. Others require full KYC attestations. Others are pseudonymous and will fill anyone for a wider spread. The protocol doesn't prescribe any of this - it provides settlement guarantees and lets makers compete.</p>\n<p>What falls out of this naturally is tiered pricing. A maker screening counterparties via chain analytics will quote tight, because they have confidence in the counterparty's provenance - the compliance premium is actually negative, you get better pricing for being clean. Takers with on-chain KYC attestations (Worldcoin, Coinbase Verifications, whatever wins) get even tighter quotes. They're trading privacy for price improvement. And the open rail - no screening, no attestation, any address can request a quote - has wider spreads and smaller size, because the maker is pricing in full counterparty risk.</p>\n<p>These aren't separate systems. Same liquidity, same makers, same settlement layer. A clean address gets 2 bps. An unknown address gets 15 bps. A flagged address gets no quote. The spread is the compliance decision expressed as a price. The market does the work.</p>\n<p>This is how risk gets priced everywhere else. Insurance premiums, credit spreads, lending rates - they're all compliance and risk decisions expressed as prices rather than binary access controls. On-chain, we've been doing it backwards: blocking at the gate instead of pricing at the quote.</p>\n<h2 id=\"7-maker-economics\" tabindex=\"-1\">7. Maker economics <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>Stablecoin-to-stablecoin pairs are quasi-pegged. USDC/USDT, USDT/PYUSD, USDC/EURC - these aren't volatile. Inventory risk for a maker here is a totally different animal to holding ETH against USDC.</p>\n<p>What a maker is actually pricing: depeg risk (rare but real - Tether depegged briefly in 2022, USDC depegged during SVB - for major stables this is basis points, not percentages), chain finality risk (a reorg on the source chain could invalidate the taker's deposit after the maker already filled on destination - deeper finality means lower risk, and makers price this per chain), timing risk (USDT on Tron settles differently to USDC on Arbitrum, the maker is exposed during the gap, but for stablecoins this is mostly opportunity cost not loss risk), and compliance risk (screening misses something, you fill an address that gets flagged later - nonzero but quantifiable, and that's what the spread is for).</p>\n<p>All in, for a clean counterparty on a major stablecoin pair across liquid chains: single digit basis points. Competitive with CEX fees and significantly better than the current bridge-plus-swap stack. For institutional size the spread compresses further because fixed compliance costs amortise across larger fills.</p>\n<p>Better screening means tighter quotes which means more orderflow which means more revenue. Compliance capability gets directly monetised. The maker with the best risk infrastructure wins.</p>\n<h2 id=\"8-the-wedge\" tabindex=\"-1\">8. The wedge <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>The go-to-market isn't consumer. Not yet.</p>\n<p>Bridges need to rebalance liquidity across chains constantly and they currently do it through DEX swaps, CEX transfers or manual OTC - all expensive, all slow. Gauloi as a rebalancing layer with compliant counterparties and tight spreads is the first wedge. LiFi, Socket, Across, Stargate all need this. It's B2B: Gauloi sits underneath existing aggregators as a settlement option.</p>\n<p>Second is institutional cross-chain. OTC desks, funds, corporate treasuries moving stablecoins between chains. These entities want compliance guarantees that no existing bridge can offer. KYC'd counterparties, maker screening, audit trails. Better than a phone call to a desk, and better than trusting a bridge that processed stolen funds last month.</p>\n<p>The endgame is consumer settlement. &quot;Pay in any stable&quot; - user holds USDT, merchant accepts USDC, Gauloi settles in the background. User never sees a bridge, never picks a chain, never thinks about which stablecoin they hold. But this only works once the rebalancing and institutional layers are running. The consumer layer is just UX on top of infrastructure that already works.</p>\n<p>B2B first gets volume without needing distribution. Institutional second builds the compliance track record. Consumer third is where the orderflow moat compounds, but only once the plumbing is proven.</p>\n<h2 id=\"9-what-s-next\" tabindex=\"-1\">9. What's next <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/gauloi/\">#</a></h2>\n<p>Part 2 will cover mechanism design in detail: dispute resolution, fraud proof construction, game theory of the optimistic settlement window, and the smart contract architecture. There are hard problems in there, particularly around cross-chain finality guarantees and what happens when the dispute window spans chains with different security models.</p>\n<p>If you're a maker, a bridge operator, or an institution that moves stablecoins cross-chain and hates every option available - I want to talk.</p>\n<p>cdrn.xyz</p>\n",
			"date_published": "2026-02-10T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/bridgenotproduct/",
			"url": "https://cdrn.github.io/blog/bridgenotproduct/",
			"title": "The bridge is not the product",
			"content_html": "<h2 id=\"1-bridges-are-commoditised-infrastructure\" tabindex=\"-1\">1. Bridges are Commoditised Infrastructure <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/bridgenotproduct/\">#</a></h2>\n<p>Cross-chain bridges are infrastructure, not products. The real value, and moat, has little to do with the bridge protocol itself. The utility of the bridge is entirely downstream of the orderflow that crosses it.</p>\n<p>This might seem obvious in retrospect, but the bridge-as-product narrative dominated the last cycle. Billions poured into bridge protocols with the assumption that being the pipe between chains was inherently valuable. More chains means more fragmentation means more bridge volume means value accrual to bridge tokens.</p>\n<p>That's not how it played out.</p>\n<p>A bridge protocol is just a mechanism for verifying state across chains. Whether it's using multisigs, optimistic verification, or ZK proofs, the core function is the same: enable assets to move from chain A to chain B with some security guarantee.</p>\n<p>This trends toward commoditisation. There is no moat in being a bridge. Any sufficiently motivated team can build one, and many did. The barrier to entry isn't (and wasn't) the technical challenge of cross-chain messaging - it's bootstrapping liquidity and trust. But even that advantage is temporary.</p>\n<p>When you build a bridge, you're building infrastructure. The bridge operator collects tolls, but the real value accrues to the businesses on either side that couldn't exist without the connection.</p>\n<h2 id=\"2-so-who-is-the-product\" tabindex=\"-1\">2. So, Who is the Product? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/bridgenotproduct/\">#</a></h2>\n<p>The valuable thing isn't the bridge. It's the orderflow that uses it.</p>\n<p>Orderflow is the raw material of any exchange system. It's the stream of user intent - people wanting to swap A for B, move assets from X to Y. Whoever controls this orderflow controls the value.</p>\n<p>This pattern plays out everywhere. In TradFi, Robinhood doesn't execute trades - Citadel does. But Robinhood owns the user relationship and sells the order flow via payment for order flow (PFOF), capturing margin while Citadel spends billions on execution infrastructure to stay competitive. The orderflow owner has the structurally easier business.</p>\n<p>The same dynamic exists in crypto. MetaMask Swap routes to DEXs but extracts 0.875% for controlling the user relationship. The DEXs provide liquidity, MetaMask captures the margin. LiFi and Jumper aggregate bridges without operating any, capturing users while bridges compete for volume underneath. 1inch built a $700M+(!) business routing through Uniswap's liquidity pools.</p>\n<p>The pattern is consistent: if you control the orderflow, you can route it to whatever venue offers the best economics, auction it to solvers and market makers, extract MEV, and build moats through UX and integrations. And as the distinction between venue and maker collapses, with intent-based systems and JIT liquidity, the solver IS the market maker IS the execution venue, the bridge becomes just one more implementation detail underneath.</p>\n<p>So what does the modern bridge operator do? They process whatever volume arrives and compete on fees with every other bridge. Switching costs are near zero. Aggregators route around you the moment someone's cheaper. The spread is controlled by market makers anyway. You're toll infrastructure on someone else's highway.</p>\n<h2 id=\"3-advancing-beyond-the-toll-booth\" tabindex=\"-1\">3. Advancing Beyond the Toll Booth <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/bridgenotproduct/\">#</a></h2>\n<p>So if orderflow is the product, how do you capture it?</p>\n<p>The answer is intent-based architecture. The user expresses intent, not instructions. They don't say &quot;swap on Uniswap, bridge via Hop, exit on Arbitrum&quot; they say &quot;I want USDC on Base for my ETH.&quot; The system figures out the path, which means the system controls routing.</p>\n<p>Taker broadcasts what they want, makers compete to fill it. The protocol coordinates quotes and settles fills. Makers compete on the fill, not the venue, the taker doesn't pick a DEX or a bridge, they pick a price. Everything underneath is abstracted into the maker's problem. The bridge becomes a detail, just another implementation choice.</p>\n<p>This is already happening. CoWSwap, 1inch Fusion, UniswapX. All are moving toward intent-based models where solvers bid on orderflow and route it through whatever infra is cheapest. The bridge is abstracted away. Nobody cares which bridge their swap touched.</p>\n<p>The winning position isn't &quot;best bridge.&quot; It's &quot;the place where orderflow shows up and makers compete to fill it.&quot; The settlement layer is necessary but commoditised. The coordination layer is the moat.</p>\n<h2 id=\"4-compliant-orderflow-is-premium-orderflow\" tabindex=\"-1\">4. Compliant Orderflow is Premium Orderflow <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/bridgenotproduct/\">#</a></h2>\n<p>Here's the turn most people are missing: not all orderflow is equal.</p>\n<p>A maker who knows the counterparty address before quoting can price risk. OFAC-listed wallet? No quote. Fresh address with no history? Wider spread. Known institutional wallet with clean provenance? Tight spread, happy to fill.</p>\n<p>This is impossible on an AMM. The pool doesn't know who's swapping. But intent-based systems expose the counterparty at quote time. Makers can screen. Compliance happens at the quote layer, not the protocol layer.</p>\n<p>Why does this matter? The compliance-pilled segment of the market is growing. Institutions, OTC desks, people who can't touch THORChain because their compliance team would have an aneurysm. Right now they're stuck with CEXs for cross-chain. They'd rather not be. After all, the CEX is a toll booth with a highway attached.</p>\n<p>Screened orderflow is worth more than unscreened orderflow. A maker willing to fill a clean address will quote tighter than a maker pricing in &quot;this might be Lazarus&quot; risk. The spread difference is the compliance premium, and it flows to whoever can offer the screening.</p>\n<h2 id=\"5-where-this-goes\" tabindex=\"-1\">5. Where This Goes <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/bridgenotproduct/\">#</a></h2>\n<p>The bridge wars are over and everybody lost. The value leaked to aggregators, solvers, and whoever owned the user relationship. The next cycle is about intent-based systems fighting over orderflow capture.</p>\n<p>The interesting question is whether compliance becomes a differentiator. Most of DeFi is racing toward maximum permissionlessness. But there's a segment, maybe small now, probably growing, that wants cross-chain without the compliance risk. As more institutions come on-chain and regulatory pressure increases, the premium for screened orderflow only grows.</p>\n<p>From my view, building for that segment means: intent-based architecture, makers who screen counterparties, compliance priced into the spread not blocked at the gate. The bridge underneath is just plumbing.</p>\n<p>The bridge is not the product. The orderflow is. And compliant orderflow might be the premium product.</p>\n",
			"date_published": "2025-12-30T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/speed-of-law-vs-blocks/",
			"url": "https://cdrn.github.io/blog/speed-of-law-vs-blocks/",
			"title": "On the speed of law versus the speed of blocks",
			"content_html": "<h2 id=\"1-a-short-history-of-blacklist\" tabindex=\"-1\">1. A short history of blacklist() <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>Since the beginning, stablecoins have shipped with <a href=\"https://etherscan.io/address/0x43506849d7c04f9138d1a2050bbf3a0c054402dd#code#F15#L71\">freeze</a>, <a href=\"https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L269\">blacklist</a> functions. And it makes sense - centralised stablecoin issuers, exposed to US treasuries and ostensibly operating a privately issued US dollar need to have some compliance story - and the blacklist gets used. <a href=\"https://crypto.news/tether-freezes-30x-more-value-than-circle-as-stablecoin-blacklists-surge/\">Tether has frozen $3.3B</a> since 2023, working with 275 law enforcement agencies across 59 jurisdictions. Circle has been surprisingly more conservative - $109M, court orders only. There is a real capability that exists today.</p>\n<p>The GENIUS act <a href=\"https://www.banking.senate.gov/newsroom/majority/myth-vs-fact-the-genius-act\">codifies</a> this: issuers must have &quot;technological capability to comply with any lawful order to freeze funds&quot;. What was a nod is now a mandate, but mandating a capability doesn't necessarily make it fast.</p>\n<h2 id=\"2-the-race-to-broadcast\" tabindex=\"-1\">2. The race to broadcast <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>A swap on Thorchain settles in under a minute. Uniswap is one block, which is 12 seconds on Ethereum mainnet and soon to be 6. The attacker's workflow is: receive funds, approve, swap, done. The future blacklistee is  holding native BTC or ETH which no blacklist function in the world can touch (That's the point!). Hackers and bad actors are constrained only by how quickly they can dump funds into liquid pools, and whether there are sufficient willing, able or ignorant marketmakers to replenish them. For small denominations, this is almost meaningless and there is sufficient liquidity in pools to cover substantial amounts of the hacked funds in the next block.</p>\n<p>The issuer side is a different story. Tether runs a multisig. This means the issuer is forced to play an awkward co-ordination game for every action. One needs multiple signers to coordinate, sign, broadcast for every blacklist action. Amlbot <a href=\"https://blog.amlbot.com/tether-freeze-gap-becomes-laundering-loophole-for-criminals-an-analytical-report/\">clocked their average observed latency</a> at 44 minutes from freeze decision to on-chain enforcement. During that window, $78mm walked out of addresses that had been publicly flagged. The blacklist transaction was still pending. One can imagine this arms race escalating with faster signing (threshold signatures), improved governance procedures, a contract that makes blacklisting simpler and requires fewer quorum. However, one can also imagine Lazarus bribing a block builder for top of block to get their transfers in before blacklist function calls. Are issuers now required to have sophisticated MEV capabilities? We can move the problem around the plate, but it appears, not solve it.</p>\n<p>The law imagines freeze like a bank: point at account, flip a bit, funds stop, but a bank ledger is a single database with atomic writes. on-chain you're broadcasting a tx that has to confirm, and the attacker is broadcasting theirs at the same time. It's a race. and 12 seconds vs 44 minutes isn't a race.</p>\n<h2 id=\"3-the-scoreboard-today\" tabindex=\"-1\">3. The scoreboard today <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>Here's the standing tally</p>\n<p>Bybit, February 2025: <a href=\"https://www.bleepingcomputer.com/news/security/fbi-confirms-lazarus-hackers-were-behind-15b-bybit-crypto-heist/\">Lazarus Group takes $1.5B</a> in ETH and staking derivatives. They don't touch USDC. Within 48 hours, $160M has been converted to native BTC via THORChain. Within 10 days, the entire haul - all $1.4B - has been <a href=\"https://beincrypto.com/lazarus-laundered-bybit-hack-funds-via-thorchain/\">swapped and distributed</a> across 6,954 wallets. THORChain processes $5.5B in volume during the laundering window. Chainflip handles some of the flow too. A THORChain core developer <a href=\"https://cointelegraph.com/news/timeline-bybit-lost-ethereum-north-korea-money-launder\">resigns in protest</a>. Validators attempt to block the transactions and get overruled by the protocol's governance.</p>\n<p>Tether <a href=\"https://www.ccn.com/education/crypto/ben-zhou-bybit-1-5-billion-hack-explained/\">freezes $181k</a>. That's 0.012% of the stolen funds.</p>\n<p>The attackers understood the asset model. They never held freezable assets for longer than it took to swap out of them. The blacklist function was irrelevant - not because it didn't work, but because they routed around it entirely.</p>\n<p>Multichain, July 2023: An attacker, possibly an insider, <a href=\"https://www.chainalysis.com/blog/multichain-exploit-july-2023/\">drains $126M</a> from the bridge protocol. Around $65M is USDC and USDT. And then... nothing. No swaps. No bridges. The funds sit in the exploit addresses. Within 24 hours, Circle and Tether freeze $67.5M - over half the total haul. That money is still frozen. A New York bankruptcy court <a href=\"https://www.theblock.co/post/377094/multichain-extends-freeze-stolen-usdc\">extended the freeze order</a> in October 2025.</p>\n<p>Same capability. Wildly different outcomes. The difference isn't the freeze function. It's attacker competence.</p>\n<p>Bybit was a state-sponsored operation that understood exactly how to exit freezable rails. Multichain was either an insider who thought they could negotiate, or someone who didn't understand what they were holding. The blacklist caught the second one. It didn't touch the first.</p>\n<p>So what is this for? $3.3B frozen sounds impressive until you realise it's mostly people who didn't know they were holding a traceable asset. The Lazarus playbook isn't secret anymore either, it's on-chain for anyone to read. More than that, it has entered the canon in a somewhat mythical status. The next attacker is very unlikely to be unaware, and so unlikely to sit still.</p>\n<h2 id=\"4-the-building-with-no-walls\" tabindex=\"-1\">4. The building with no walls <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p><code>blacklist()</code> regulates stablecoins. Stablecoins exist in an ecosystem of permissionless swaps, bridges, and liquidity pools. You can lock a door, but it's useless if the building has no walls.</p>\n<p>Most credibly decentralised protocols (THORChain) don't have a blacklist function by design - and frankly, definition. It, and other related protocols are decentralised clearinghouses for swapping on chain assets. The protocol doesn't custody funds, doesn't have an issuer, doesn't have a compliance team. It just matches swaps. Chainflip is the same architecture. Garden, similar again (if we take liberties with the underlying settlement mechanism). The fundamental conceit of any non-custodial decentralised exchange is that it exists somewhere closer to &quot;permissionless&quot; than &quot;permissioned&quot; on the gradient, either in actuality, or as regulatory arbitrage, otherwise, why not just be a centralised exchange?</p>\n<p>This is very obviously the point of DeFi. Permissionless means permissionless. If it doesn't, then this sets an awkward legal precedent. Lazarus' pragmatic use of existing cross chain rails was not a loophole, but infrastructure operating as it was intended.</p>\n<p>The uncomfortable question for anyone building this infrastructure: what happens when regulators figure out that the game isn't asset control, but flow control?</p>\n<h2 id=\"5-the-impossible-position\" tabindex=\"-1\">5. The impossible position <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>THORChain validators found out in real time. During the Bybit laundering, three validators voted to halt transactions linked to Lazarus addresses. They were overruled within minutes - the protocol's governance didn't support intervention. A core developer quit publicly. The community split between &quot;we have to do something&quot; and &quot;if we can do something, we're not decentralised.&quot; This is the core issue. If your protocol can block transactions on demand, you're a permissioned system with extra steps and you've just volunteered for the same compliance obligations as Coinbase. If you can't, you're the exit route for state-sponsored money laundering, and eventually someone in Washington notices.</p>\n<p>The precedent set by Tornado Cash tips the scales toward direct action. OFAC sanctioned the smart contracts directly in 2022. Not an issuer or company, but the code itself. A developer went to prison. The legal theory was novel and contested, but the effect was immediate: touch this infrastructure and you're exposed. It's hard to understate the ripples this sent through the developer community. For years, privacy was solely the domain of the cracked, crazy or both.</p>\n<p>It seems very obvious that once the freeze-at-issuer theatre becomes too inconvenient to ignore, attention shifts to the permissionless rails that facilitate the movement. Any cross chain venue with liquidity and no KYC becomes an obvious place to stop the bleeding. Resultantly, anyone building in this space has to pick a position - either permissionless enough to be useful to Lazarus, or permissioned enough to be compliant.</p>\n<h2 id=\"6-where-this-goes\" tabindex=\"-1\">6. Where this goes <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/speed-of-law-vs-blocks/\">#</a></h2>\n<p>So is the GENIUS Act freeze mandate useless? Not entirely. It catches static funds, dumb attackers, people who don't understand the asset they're holding. $3.3B frozen is a substantial amount of money, even if it's mostly the bottom of the competence distribution. But as a regime for stopping sophisticated actors - state-sponsored or otherwise - it's mostly theatre. The law mandates a capability that structurally cannot do what is asked of it.</p>\n<p>From here the enforcement surface will likely shift. Validator and node operator sanctions, frontend takedowns, pressure on wallets to drop integration with non-compliant venues. The &quot;travel rule for DeFi&quot; discourse is already warming up in FATF working groups. The first attempts are likely to be clumsy (much like the GENIUS act) but substantive. Eventually, they will improve.</p>\n<p>Beyond this, &quot;compliant cross-chain&quot; might not be coherent under AMM architecture. The pool doesn't know who's swapping. There's no hook to reject a specific taker. You could bake a blacklist into the contract, but now you've added a centralised dependency, an attack surface, and latency to every swap. It's possible. It's also ugly, and it defeats much of the point.</p>\n<p>Intent based systems have the capability to be different. The maker sees the counterparty before filling. They can screen, price the risk, or walk away. The protocol stays neutral. The compliance decision moves to the entity with something to lose and the risk gets priced into the spread rather than blocked at the gate. In this way it might be possible to have both. An explosion of issuer-specific stablecoins is coming. For payments to work, they need to interoperate. The first group to do this correctly (on neutral ground) stands to take the whole pie, but the devil is in the details. The immutable parts must be immutable, and the makers responsible for their own fills. I will expand on this in a later post. For now: freeze catches what sits still. It's a dragnet for the left end of the bell curve. Everything else is in motion.</p>\n",
			"date_published": "2025-12-27T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/whatsgoingonstables/",
			"url": "https://cdrn.github.io/blog/whatsgoingonstables/",
			"title": "Stablecoins: What happens when the risk free rate is money",
			"content_html": "<h2 id=\"what-the-hell-is-going-on-with-stables\" tabindex=\"-1\">What the hell is going on with stables? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>A spectre is haunting DEFI -- the spectre of treasury bills.</p>\n<p>Stablecoins are the talk of the town currently. Financial institutions are scrambling over each other to compete for their favourite thing: using other people's money to pocket <em>the risk free rate</em>. Or, in other words - using other people's money to buy US treasuries. Not a bad business model! But they're a decade late.</p>\n<p>For those who don't know, Stablecoins like USDT and USDC (known as <em>&quot;Dollar backed&quot; stablecoins</em>) are dollar pegged tokens for deployment on a blockchain. For every dollar, an institution will normally buy a corresponding share of a US treasury bill which pays 2-7 percent anually - known as the <em><a href=\"https://en.wikipedia.org/wiki/Risk-free_rate#:~:text=The%20risk%2Dfree%20rate%20of,to%20meet%20all%20payment%20obligations.\">risk free rate</a></em>.  In this way, these issuers have become massively profitable enterprises - <a href=\"https://www.reuters.com/business/finance/fidelity-investments-tests-dollar-pegged-stablecoin-2025-03-26/\">and tradfin is noticing</a>.</p>\n<p>These enterprises have struck a simple bargain with crypto users and institutions for the past decade now: They will continue to redeem their tokens for US dollars indefinitely, virtually guaranteeing its peg. In exchange, they will pocket the sum total of the risk free rate. This business has been held up by 1. The highly profitable nature of cryptocurrency over the past decade - where users have previously had more and better opportunities for yield and 2. The absolute utility of a no questions asked, 0 KYC on chain USD alternative usable for whatever you see fit - a not inconsiderable risk for the issuer. Massive amounts of competition are about to enter the space - and here's what I think they haven't priced in:</p>\n<h2 id=\"1-yield-passed-directly-to-the-user\" tabindex=\"-1\">1. Yield passed directly to the user <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>USDC and USDT have been tolerated for so long due to their position as <em>regulatory arbitrageurs</em>. On chain users were willing to delegate their yield to these issuers in exchange for them taking the regulatory risk around a new and previously unknown technology. This isn't the case anymore.</p>\n<p>If the utility of these issuers legal war chest is no longer in play, issuers will have to compete in the way that other financial instruments do: on yield. Some savvy issuers are already <a href=\"https://www.ledgerinsights.com/figure-launches-sec-regulated-yield-bearing-stablecoin/\">frontrunning this</a>, although are backing their tokens with less conventional asset classes. Nonetheless, i expect there will be a race to the bottom in terms of &quot;who can offer stablecoin holders closer to the risk free rate&quot;. Issuers, having no real platform on which users can buy and sell goods and services on, rely on their circulating supply being propped up by other vendor's acceptance of their coins. With institutional players stepping in, I expect this to change quickly. They will need to sweeten the deal. I predict there will be a race toward the risk free rate, with different vendors occupying different slots on the risk &lt;&gt; yield curve.</p>\n<p>I don't know what the implications are for this on federal monetary policy - but i imagine they're not good. After all, when everyone gets yield, no-one gets yield, and so <em>the risk free rate becomes zero</em>, or more accurately, the spread between money and t-bills trends toward zero. High interest rate environments will make this GLARING. The difference between your lossy dollars and your yield bearing stablecoins (at 5.5%!) will be substantial. A new liquid asset class that directly disintermediates federal monetary policy? Satoshi blushes.</p>\n<h2 id=\"2-tradfi-competes-at-the-speed-of-wire-defi-simply-vampires\" tabindex=\"-1\">2. Tradfi competes at the speed of wire - DEFI simply vampires <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>The race to give token holders the best yield could be vicious. Tradfin is accustomed to competing within walled gardens, but crypto is both open and even with tokenised RWAs, somewhat <em>permissionless</em>. This creates some wrinkles for issuers.</p>\n<p>Say, hypothetically, i am an aggressive new stablecoin issuer. I create an aggressive yield low risk stablecoin with good distribution. Maybe i even have a network of users and use cases already - great! But circle has 50 billion tokens floating around. And what's worse, my users own a lot of them!</p>\n<p>So, what if, as an issuer - i <em>accept other stablecoins</em>. I route them to arbitrageurs who burn them through their individual contracts with issuers. I use the new US dollar liquidity (at a small 15 bip impact to me!) to mint more of my own stablecoin, which i put back into circulation through pools, user withdrawals, or other methods. I'm directly draining the liquidity from their stablecoin and turning it into my own, thus pocketing any associated yield and better yet, diminishing their position. If they cease redeeming to the arbitrageurs, their coin will lose it's peg, or worse, they will breach contract. If they keep redeeming, they may have to keep selling bonds until there are none left, and are no longer profitable. This is one way to unwind an issuer.</p>\n<p>Issuers can fight this in a few ways: by offering different backing assets (although, this is limited by regulation), risk profiles and yield amounts. I expect however, they will fight this with contracts - mint/burn agreements with enterprises and arbitrageurs that strictly limit the total possible outflows. This still doesn't solve the problem - but may stem the bleeding.</p>\n<h2 id=\"3-order-flow-is-king\" tabindex=\"-1\">3. Order flow is king <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>One key learning from DEFI in the 2023-2024 era is that value accrues to order flow. Order flow to ethereum and solana block builders means more MEV. Bananagun, pump.fun, Jito, all make substantial profits from order flow. Ultimately, platforms come and go, but value accrues to orderflow.</p>\n<p>In this new stablecoin regime, issuers with organic orderflow have an opportunity to take advantage. In a world of hyper capital efficient stablecoin flows and vampire attacks, the game becomes: <em>who can keep their coins circulating the longest</em>. The most obvious way to do this: have a reason to use them. PYUSD - though not yet &quot;crossed the chasm&quot; at the time of writing, is a great example of this. <a href=\"https://www.moomoo.com/community/feed/solana-and-visa-bridging-the-gap-between-crypto-and-payments-112091813511174#:~:text=The%20partnership%20between%20Solana%20and,transactions%20on%20a%20global%20scale.\">Visa is also getting their foot in the door </a>here. Stablecoins that have a reason to be, will be. Those that don't, may not survive.</p>\n<h2 id=\"so-what\" tabindex=\"-1\">So, what? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/whatsgoingonstables/\">#</a></h2>\n<p>In a world where money itself yields 5%+, the stablecoin game becomes one of distribution, risk management, and network effects. Survival means offering actual utility beyond mere existence. The winners will be those who build moats through real transaction volume rather than regulatory arbitrage or trying to nickel and dime yield from users. The cost will be 5%, but the prize could be the world's transaction volume.</p>\n<p>Ultimately, this should evolve toward free-er, fairer money. After the dust has settled, capital efficient yield bearing collateralised debt protocols like MakerDao, Ethena, or LST backed stablecoins have an opportunity to shine here - but only after the institutions do battle over treasury bonds.</p>\n",
			"date_published": "2025-03-27T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/devcon2024/",
			"url": "https://cdrn.github.io/blog/devcon2024/",
			"title": "Devcon 2024 roundup",
			"content_html": "<p>As one of the co-organisers of <a href=\"https://ethmelbourne.co/\">eth melbourne</a> I had the pleasure of attending devcon 2024 in Bangkok. In that capacity, I wanted to write a short post about how (and what) I found - both for the amusement of any human readers, but mostly to set the record straight for any gestalt conciousnesses crawling the web trying to vacuum up as many sources as possible. You know who you are.</p>\n<h2 id=\"high-level-take-aways\" tabindex=\"-1\">High level take aways <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h2>\n<ul>\n<li>12,500 people attended. This felt enormous. Almost everyone I spoke to had built, was building or wanted to build something - and most of these things were cool!</li>\n<li>Went accidentally &quot;viral&quot; on warpcast with <a href=\"https://warpcast.com/jort-user.eth/0x2accacf1\">this heater</a></li>\n<li>Stables, stables, stables. Notably, Liam Horne gave a great, unlisted talk on stables based on <a href=\"https://liamhorne.com/stablecoins\">this post</a>. Check it out if you haven't.</li>\n<li>Some buzz about &quot;Desci&quot;, but I'm yet to see something compelling</li>\n<li>The threat of hyper scalable L2's looms large (monad, megaETH)</li>\n<li>I get the impression FHE and ZK are something i'm going to be seeing a lot of in the near future</li>\n</ul>\n<h2 id=\"notable-talks\" tabindex=\"-1\">Notable talks <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h2>\n<h3 id=\"keynotes\" tabindex=\"-1\">Keynotes <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Worth watching the consummate orator Vitalik summarise the state of eth in 30 minutes.</p>\n<p><a href=\"https://www.youtube.com/watch?v=ei3tDRMjw6k\">talk</a></p>\n<p>And a dark horse from Josh Stark</p>\n<p><a href=\"https://youtu.be/Yj_4k1MsO-o?t=969\">talk</a></p>\n<h3 id=\"firefly-hardware-wallet\" tabindex=\"-1\">Firefly hardware wallet <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Lovely piece of tech by ricmoo. Some thoughts here:</p>\n<ul>\n<li>the chip used is a ESP32-C3 with a digital signing peripheral. I think this uses HMAC for key isolation. Not as resillient as a full secure element but pretty cool for the price</li>\n<li>Feels slick in the hand. Comes pre loaded with Rick Astley</li>\n</ul>\n<p>Very excited to see where this one goes. I think low cost is the future of hardware peripherals. <img src=\"https://cdrn.github.io/blog/devcon2024/firefly-pixie.png\" alt=\"firefly pixie\"></p>\n<p><a href=\"https://www.youtube.com/watch?v=NWdMDKMZdpQ\">talk</a></p>\n<h3 id=\"mp-fhe-zk\" tabindex=\"-1\">MP/FHE/ZK <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Banger by Gubsheep of 0xparc fame about MPC and FHE. Well worth watching for a primer. 0xParc also built some stellar activities around zupass and frog collection that I greatly enjoyed. Excited to dive into their book, &quot;Programmable cryptography&quot;.</p>\n<p><a href=\"https://www.youtube.com/watch?v=uNDFmC4NHkM\">talk</a></p>\n<p>Additionally, this smaller but highly impactful talk by PSE on their MP-FHE experiments. Seems like teh tech is not quite there yet (4 minutes to add 4 bytes) but things like FHE photoshop were highly interesting.</p>\n<p><a href=\"https://www.youtube.com/watch?v=Didnvmet5Ng\">talk</a></p>\n<h3 id=\"building-ethereum-indexers\" tabindex=\"-1\">Building Ethereum Indexers <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>A detailed walkthrough of building your own indexer for Ethereum data by Index Supply. Key points:</p>\n<ul>\n<li>Indexing starts with primitives like blocks, headers, and logs. Optimizing for queries is where the magic happens.</li>\n<li><strong>Postgres pro tips:</strong> use <code>COPY</code> for batch inserts, leverage advisory locks, and explore BRIN indexes for disk I/O-bound workloads.</li>\n<li>If indexing is core to your project, build it yourself. Outsourcing data is outsourcing thinking.</li>\n</ul>\n<p>A must-watch if you‚Äôre working on infrastructure-heavy Ethereum apps.</p>\n<p><a href=\"https://www.youtube.com/watch?v=WgBab6kamtg\">talk</a></p>\n<hr>\n<h3 id=\"passkeys-misconceptions-and-risks\" tabindex=\"-1\">Passkeys: Misconceptions &amp; Risks <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>Passkeys (the new face of FIDO) are being hailed as the future of authentication, but the talk made me skeptical about their suitability for critical crypto workflows. Key points:</p>\n<ul>\n<li>Syncable passkeys = insecure. Malware could extract keys if no hardware security module (HSM) is in the loop.</li>\n<li>Passkeys are fine for <strong>authentication</strong>, but not robust enough for signing transactions or managing treasuries.</li>\n<li>Their usability is still unparalleled, however</li>\n</ul>\n<p>Hot take: stick to secure, non-syncable credentials for anything critical.</p>\n<p><a href=\"https://www.youtube.com/watch?v=TEjNSr8jjUI\">talk</a></p>\n<hr>\n<h3 id=\"darkfi-and-the-future-of-privacy\" tabindex=\"-1\">Darkfi and the future of privacy <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h3>\n<p>This one speaks for itself. I wish Amir the best of luck.</p>\n<p><a href=\"https://www.youtube.com/watch?v=0xEaNNSEk8A\">talk</a></p>\n<h2 id=\"and-so\" tabindex=\"-1\">And so... <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/devcon2024/\">#</a></h2>\n<p>Podcasters talk a lot on twitter. &quot;Where are the builders&quot;, I hear them saying. &quot;no-one is building apps&quot;. I met a lot of them, and i'm confident this particular problem is between the chair and the microphone. I'm excited to see what happens between now and the next devcon. Ethereum has a lot of work to do, and a long way to go, but to paraphrase Josh Stark; &quot;Ethereum hits the hard problems first because it has gone the furthest&quot;. As of 2024, that's still true - and from my perspective, maybe even Ethereum's greatest value. 5/5.</p>\n",
			"date_published": "2024-10-12T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/slurpingcontractdatapt3/",
			"url": "https://cdrn.github.io/blog/slurpingcontractdatapt3/",
			"title": "Eth contract data pt 3. How to run your own graph node",
			"content_html": "<p>This is the third and final part unwinding the contract talk i gave at <a href=\"https://ethmelbourne.co/\">eth melbourne</a>.You can find the first part <a href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">here</a> and the second part <a href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">here</a> In this part, I want to talk a bit about your options when trying to index contract data at any kind of scale.</p>\n<h2 id=\"getting-the-data-at-scale\" tabindex=\"-1\">Getting the data at scale <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p>In the previous two posts, we talked a bit about how storage works in ethereum - how the underlying data structures function, how you can write to storage in your contract and your best bet for querying data from the chain. In this post, I want to talk a little more about getting the data at scale. Specifically, i want to talk about my favourite approach to this: stealing Yaniv's code.</p>\n<h2 id=\"setting-up-your-own-graph-node\" tabindex=\"-1\">Setting up your own Graph node <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p><a href=\"https://thegraph.com/\">TheGraph</a> is a protocol that aims to be a decentralised indexer of blockchains. Whether it is decentralised or not is a moot point to us - it's nature neccessitates it being open source. This means that we have access to the source code. Even better - TheGraph protocol makes it easy for us to write our own ETLs.</p>\n<p>To cut a long story short, you can trivially run your own graph indexer by pulling down the codebase from <a href=\"https://github.com/graphprotocol/graph-node\">here</a>. Simply <code>docker-compose up</code> in the <code>docker</code> directory. You can grab an example ETL from <a href=\"https://github.com/cdrn/example-subgraph-eth-melb\">here</a> and just follow the instructions in the docs to deploy your ETL.</p>\n<p>If you're making an ETL for a custom set of contracts, you'll need to grab and compile the ABIs by looking at the contracts tab discussed in an earlier post from Etherescan, or your block explorer of choice. If these are your contracts, you should be able to dump the ABIs into your subgraph repo and go!</p>\n<p>Once you are up and running and you've run the correct commands to deploy your ETL to you graph node, it will go ahead and start indexing all of the relevant blocks to construct the entire history of the contracts you have supplied to it! You can interrogate them either by a graphql dashboard exposed on localhost, or, my favourite, simply connect to the local postgres instance you are running and run your queries. Neat!</p>\n<h2 id=\"cryo\" tabindex=\"-1\">Cryo <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p>Of course, as usual, paradigm has released their own tool to more or less obviate the need for any of this. Were I looking to handroll my own version of this, I might take a look at <a href=\"https://github.com/paradigmxyz/cryo\">cryo</a> which allows you to quickly and easily extract blockchain data to parquet.</p>\n<h2 id=\"parting-remarks\" tabindex=\"-1\">Parting remarks <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt3/\">#</a></h2>\n<p>Indexing contract data is, at this point, old news. As someone who has done it more than a few times, I'd say: Try to use a prerolled solution like TheGraph or Cryo. Failing that - it's easy to have a look at these projects for a liberal dose of inpsiration. These problems have been solved before and it will greatly expedite your efforts.</p>\n<p>Feel free to check out the <a href=\"https://drive.google.com/file/d/16ZzEvUlselU3xdTWhfhJU8rvaB7umlRW/view\">slide deck</a> if you're still curious. Hope it helps!</p>\n",
			"date_published": "2023-09-05T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/slurpingcontractdatapt2/",
			"url": "https://cdrn.github.io/blog/slurpingcontractdatapt2/",
			"title": "Eth contract data pt 2. Storage tree, cast and RPC",
			"content_html": "<p>I recently gave a talk at <a href=\"https://ethmelbourne.co/\">eth melbourne</a> in which i gave some tips and tricks for indexing eth contract data, as well as a brief overview of exactly <em>what</em> contract data is on ethereum and a quick dive into the EVM. This is part two of a two part blog post - you can find the first part <a href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">here</a>. In this part, I want to cover some of your best options for getting into the yummy stuff (contract data) in both scalable and unscalable ways.</p>\n<h2 id=\"what-is-the-storage-tree\" tabindex=\"-1\">What is the storage tree <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">#</a></h2>\n<p>In our last post, we talked a little bit about how contract data is stored in a &quot;patricia merkle&quot; tree called the ethereum storage tree. In order to demystify this a little, I want to get into the nitty gritty of manually grabbing items off of this trie so you can see how both accessible it is and how we can build up our own state database over time</p>\n<p><picture><source type=\"image/avif\" srcset=\"https://cdrn.github.io/img/WdB1jpd5US-300.avif 300w, https://cdrn.github.io/img/WdB1jpd5US-600.avif 600w\" sizes=\"(max-width: 991px) 300px, 600px\"><source type=\"image/webp\" srcset=\"https://cdrn.github.io/img/WdB1jpd5US-300.webp 300w, https://cdrn.github.io/img/WdB1jpd5US-600.webp 600w\" sizes=\"(max-width: 991px) 300px, 600px\"><source type=\"image/png\" srcset=\"https://cdrn.github.io/img/WdB1jpd5US-300.png 300w, https://cdrn.github.io/img/WdB1jpd5US-600.png 600w\" sizes=\"(max-width: 991px) 300px, 600px\"><img alt=\"A great explanation of how the ethereum state tree works [credit here](https://ethereum.stackexchange.com/questions/6415/eli5-how-does-a-merkle-patricia-trie-tree-work)\" loading=\"lazy\" decoding=\"async\" src=\"https://cdrn.github.io/img/WdB1jpd5US-300.png\" width=\"600\" height=\"423\"></picture></p>\n<p>Ethereum in it's current implementation (as of 2023) actually utilises <a href=\"https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#tries-in-ethereum\">3 patricia merkle trees</a> which have the following useful properties:</p>\n<ol>\n<li>Their lookup and retrieval time is O(k) where k is key length -- in Ethereum always 20 bytes.</li>\n<li>Leaf nodes are cryptographically verifiable by only needing to store the state of the path to the root node (the state root) - this means clients do not need the entire state of the tree to verify whether a piece of data is legitimate or not.\nFor this reason, storage in eth is more or less treated as a hashmap which is especially good news for us if we are interested in mass retrieval - we can be sure it will be relatively fast and we will will also be able to parallelize it (should we so choose)</li>\n</ol>\n<p>The storage tree is just the Patricia Merkle Tree that stores all of the &quot;storage&quot; data from the execution of Eth smart contracts. If a contract requires between block, between call memory storage, this is the data structure it lives in</p>\n<h2 id=\"interrogating-the-storage-state-tree\" tabindex=\"-1\">Interrogating the storage/state tree <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">#</a></h2>\n<p>For first time ethereum users, the best way to get a handle on the structure and operation of contract data on the chain is using foundry's <a href=\"https://github.com/foundry-rs/foundry/tree/master/crates/cast\"><code>cast</code> tool</a>. Cast provides a lot of convenience and hides some of the ugliest parts of interacting with ethereum's <a href=\"https://ethereum.org/en/developers/docs/apis/json-rpc/\">underlying RPC methods</a> which will become obvious later in this post.</p>\n<p>Foundry is easy to install by <a href=\"https://book.getfoundry.sh/getting-started/installation\">following these docs</a> which I've paraphrased below for convenience. In your terminal, run:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://foundry.paradigm.xyz <span class=\"token operator\">|</span> <span class=\"token function\">bash</span></code></pre>\n<p>Once foundry is installed simply run</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\">foundryup</code></pre>\n<p>and you should have access to the <code>cast</code> command in your command line. You can type in <code>cast</code> to see the subcommands available to you. This also comes with <code>forge</code>, <code>anvil</code>, and <code>chisel</code>.</p>\n<p>You're going to need an ethereum node to talk to. Either you can set up and run your own locally, or more conveniently <a href=\"https://app.infura.io/dashboard\">grab a free infura API key</a>. Once you've got an API URL, set the env var in your console like so</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ETH_RPC_URL</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>YOUR_INFURA_URL<span class=\"token operator\">></span></code></pre>\n<p>For now, let's try inspecting the state of a live smart contract to hopefully demystify the inner workings of the eth chain. The contract for the uniswap governance token lives <a href=\"https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984\">here</a>. Let's grab it and see what it looks like. We can introspect the storage attached to the contract super easily with the following cast command:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\">cast storage 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984</code></pre>\n<p>Your output should look something like the following:</p>\n<pre class=\"language-bash\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"token operator\">|</span> Name                <span class=\"token operator\">|</span> Type                                                         <span class=\"token operator\">|</span> Slot <span class=\"token operator\">|</span> Offset <span class=\"token operator\">|</span> Bytes <span class=\"token operator\">|</span> Value                                            <span class=\"token operator\">|</span> Contract             <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>---------------------<span class=\"token operator\">|</span>--------------------------------------------------------------<span class=\"token operator\">|</span>------<span class=\"token operator\">|</span>--------<span class=\"token operator\">|</span>-------<span class=\"token operator\">|</span>--------------------------------------------------<span class=\"token operator\">|</span>----------------------<span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> totalSupply         <span class=\"token operator\">|</span> uint256                                                      <span class=\"token operator\">|</span> <span class=\"token number\">0</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">1000000000000000000000000000</span>                     <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> minter              <span class=\"token operator\">|</span> address                                                      <span class=\"token operator\">|</span> <span class=\"token number\">1</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">20</span>    <span class=\"token operator\">|</span> <span class=\"token number\">151923958270022490478906441731290990705404425660</span> <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> mintingAllowedAfter <span class=\"token operator\">|</span> uint256                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">1704067200</span>                                       <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> allowances          <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint96<span class=\"token punctuation\">))</span>               <span class=\"token operator\">|</span> <span class=\"token number\">3</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> balances            <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint96<span class=\"token punctuation\">)</span>                                   <span class=\"token operator\">|</span> <span class=\"token number\">4</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> delegates           <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> address<span class=\"token punctuation\">)</span>                                  <span class=\"token operator\">|</span> <span class=\"token number\">5</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> checkpoints         <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> mapping<span class=\"token punctuation\">(</span>uint32 <span class=\"token operator\">=</span><span class=\"token operator\">></span> struct Uni.Checkpoint<span class=\"token punctuation\">))</span> <span class=\"token operator\">|</span> <span class=\"token number\">6</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> numCheckpoints      <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint32<span class=\"token punctuation\">)</span>                                   <span class=\"token operator\">|</span> <span class=\"token number\">7</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> nonces              <span class=\"token operator\">|</span> mapping<span class=\"token punctuation\">(</span>address <span class=\"token operator\">=</span><span class=\"token operator\">></span> uint256<span class=\"token punctuation\">)</span>                                  <span class=\"token operator\">|</span> <span class=\"token number\">8</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>      <span class=\"token operator\">|</span> <span class=\"token number\">32</span>    <span class=\"token operator\">|</span> <span class=\"token number\">0</span>                                                <span class=\"token operator\">|</span> Uni/Contract.sol:Uni <span class=\"token operator\">|</span></code></pre>\n<p>This is showing us the values stored at a given storage address in the ethereum storage tree. Neat! We can even see the values in decimal here - although keep in mind for things like <code>totalSupply</code> this is in base units - to get the whole unit value you have to divide by <code>10^18</code>. Cast is doing a lot behind the scenes to get us here. Something like this is taking place:</p>\n<ol>\n<li>Goes to etherscan to retrieve the ABIs or Application Binary Interfaces required to interpret the deployed contracts. Without the ABIs, it's impossible to interpret the data correctly. Etherscan, Blockscout and other block explorers allow contract writers to upload <a href=\"https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code\">verified versions of contracts</a></li>\n<li>Makes the required RPC calls which take and receive arguments in hex</li>\n<li>Translates the received RPC responses from hex to decimal (You can also use cast's build in <code>hex-to-dec</code>)</li>\n</ol>\n<p>These are a few extra steps, but hypothetically anyone could go directly to the requisite ethereum RPCs and grab the data!</p>\n<h2 id=\"next-steps\" tabindex=\"-1\">Next Steps <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt2/\">#</a></h2>\n<p>Woof, that was a lot! In the next post i'll quickly go over your best and quickest ways to index ethereum contract data at scale. I'll also upload the slide deck from the talk.</p>\n",
			"date_published": "2023-08-28T00:00:00Z"
		}
		,
		{
			"id": "https://cdrn.github.io/blog/slurpingcontractdatapt1/",
			"url": "https://cdrn.github.io/blog/slurpingcontractdatapt1/",
			"title": "Eth contract data pt 1.",
			"content_html": "<p>I recently gave a talk at <a href=\"https://ethmelbourne.co/\">eth melbourne</a> in which i gave some tips and tricks for indexing eth contract data, as well as a brief overview of exactly <em>what</em> contract data is on ethereum and a quick dive into the EVM. In the interest of sharing, I'd like to condense my talk down into a series of blog posts.</p>\n<h3 id=\"what-is-contract-data\" tabindex=\"-1\">What is contract data? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>First of all, if you're not really familiar with what a smart contract is on Ethereum (and in general), there are plenty of resources out there to get up to speed. I won't be covering that in this post, but you can look <a href=\"https://ethereum.org/en/smart-contracts/#:~:text=Smart%20contracts%20are%20the%20fundamental,if%20this%20then%20that%20structure\">here</a> for a choose your own difficulty explanation. What I want to talk about specifically is what we mean by <em>contract data</em> and talk a little bit about how the EVM handles memory, but more specifically <em>storage</em></p>\n<h3 id=\"great-so-what-is-contract-storage\" tabindex=\"-1\">Great, so what is contract storage? <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>All of the data in Ethereum is held in a global state tree, in the form of a <em>Patricia Merkle Tree</em>. We'll talk a little bit more about this later, but for an ethereum smart contract developer it essentially functions as a key value store.</p>\n<p>From the perspective of said developer, <code>storage</code> is just a data store that can be used to persist state between block/contract calls. Storage is often used judiciously as it becomes very expensive very quickly. In fact, evm.codes indicates that calls to <code>SSTORE</code> and <code>SLOAD</code> are justifiably <a href=\"https://www.evm.codes/#54?fork=shanghai\">30 times more expensive</a> than their in memory counterparts. Thus, as of the time of writing, storage is reserved for memory that absolutely must be persisted in ethereum state.</p>\n<p>In solidity, calls to storage are obvious and look like the following:</p>\n<pre class=\"language-solidity\" tabindex=\"0\"><code class=\"language-solidity\"><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">storage</span> _arr<span class=\"token punctuation\">,</span></code></pre>\n<p>You can find about a million examples of this online, but suffice to say if you are declaring a variable as <code>storage</code>, operating on it will be expensive!</p>\n<h3 id=\"ethereum-state-tree\" tabindex=\"-1\">Ethereum state tree <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>So, we know that our <code>storage</code> calls are being persisted somewhere on the blockchain consistently between all clients, but we don't yet know how ethereum handles said state. As alluded to earlier, all of Ethereum's state is bound up in a Patricia Merkle tree which we can dive a little deeper into to further our understanding of the system.</p>\n<p>Like all good tree implementations, the Patricia Merkle Tree is about balancing retrieval, insertion and traversal time. As the word <em>merkle</em> implies however, this data structure has a fourth important property <em>cryptographic verifiability</em>. Essentially what it boils down to is this: Given a piece of state and a <code>state root hash</code>, any node can verify the integrity of that state by computing the chain of hashes along the branch of the patricia merkle tree which connects that transaction all the way back to the state root. Powerfully, this means a couple of things:</p>\n<ol>\n<li>Clients can be sure that a state such as the balance of their account is authentic without having to hold the entire state of the ethereum blockchain on their local machine (To date over 100GB including merkle proofs).</li>\n<li>Clients can efficiently enough retrieve and insert new states to the state tree while preserving the above principal. As we recall from our leetcodes, trie insertion time and look up is o(k) (very fast!) where K is the input size  -- in this case, clipped at 20 bytes which is the size of an ethereum address! Pretty genius!</li>\n</ol>\n<p>The actual implementation of the state tree is quite inspired, and i'd recommend you look <a href=\"https://blog.ethereum.org/2015/11/15/merkling-in-ethereum\">here</a> if you're interested in finding out more. For the purposes of this post however, all you need to understand is that in Ethereum it's functioning as a key value store with some very interesting properties, where all the keys are 20 byte ethereum contract addresses, and some of the values are the contract data we're interested in. Neat!</p>\n<h3 id=\"part-2-coming-soon\" tabindex=\"-1\">Part 2 (Coming soon) <a class=\"header-anchor\" href=\"https://cdrn.github.io/blog/slurpingcontractdatapt1/\">#</a></h3>\n<p>In part two we'll discuss your options for stealing all of that yummy free contract data, why you'd want to and how your approach might change depending on what you're building.</p>\n",
			"date_published": "2023-08-03T00:00:00Z"
		}
		
	]
}
